%!TEX root = these.tex

\chapter[Sélection de cibles : état de l'art]{État de l'art des travaux sur la sélection de cibles}
\minitoc
\label{chap2}
%\cleardoublepage
\clearpage

\section{Introduction}
	Dans le présent chapitre, nous commençons par quelques rappels sur la théorie de la sélection de cibles, et un bref état de l'art des modèles existants, en particulier lorsqu'ils sont dédiés aux cibles mobiles. Puis, nous nous attachons à établir une taxinomie des techniques de sélection les plus connues et/ou performantes. Sans être exhaustif, il s'agit de tâcher d'être représentatif, de mentionner et d'analyser les mérites et limites des principales techniques de sélection.
	
	Cette taxinomie n'a pas vocation à avoir un intérêt universel pour la sélection de cibles, mais elle est établie dans l'optique de la sélection de cibles \emph{mobiles}, et en particulier de cibles mobiles dans des environnements particulièrement difficiles : denses, souvent hétérogènes, avec beaucoup d'occultation, de mouvements vifs et imprévisibles, etc. Par conséquent, nos observations sur les différentes techniques citées plus bas sont orientées par la problématique qui nous intéresse, et ne sauraient être prises pour des évaluations absolues des techniques concernées. De fait, nous séparons les techniques selon l'objectif pour lequel elles sont conçues : pour des cibles statiques ou mobiles --- tout en admettant qu'une technique appartenant à une catégorie peut généralement être utilisée pour les cibles de l'autre. Ainsi, nous discutons des techniques de sélection fondées sur un curseur zonal (surfacique ou volumique), sur l'augmentation ou la transformation des cibles, sur l'altération du temps, sur le lancer de rayon ou la projection conique, sur la sélection à plusieurs étapes (dite en cascade), ainsi que sur la prédiction de l'intention de l'utilisateur.
	
	Remarquez que ces catégories ne sont pas mutuellement exclusives, et qu'une technique pourrait tout à la fois utiliser un curseur volumique, augmenter les cibles, éventuellement altérer le temps, se décomposer en plusieurs étapes, et tenter de prédire l'intention de l'utilisateur. La répartition des techniques décrites ici a donc nécessairement quelque chose d'arbitraire, et nous tâchons d'attribuer à chaque technique une catégorie en fonction de ce qui la distingue le plus des autres, selon ce qui nous paraît être son principe fondamental --- qui est généralement identifié et mis en avant par les auteurs de chaque technique. Outre les principes de fonctionnement et mérites apparents des techniques que nous analysons dans ce chapitre, nous nous attachons, dans la mesure du possible, à en présenter les performances mesurées empiriquement lorsqu'elle le furent. Il va sans dire qu'aucune étude n'a jamais été menée afin de comparer toutes ces techniques et que, par conséquent, les différentes mesures effectuées ne sont pas toujours directement comparables entre elles, attendu qu'elles peuvent porter sur différentes métriques, ou résulter de protocoles très différents. Nous tâchons simplement d'en tirer le plus d'enseignements possible afin d'informer au mieux le lecteur.

\section{Notions théoriques et modèles pour le pointage}
	Si les cas sur lesquels nous nous concentrons, énumérés dans le chapitre précédent, présentent des difficultés particulières, de nombreuses techniques existent déjà et certaines d'entre elles tiennent compte d'une partie de ces difficultés. L'on peut faire remonter la problématique de la recherche sur le pointage au moins jusqu'à la loi de Fitts~\cite{fitts1954information}. Celle-ci fut établie notamment grâce à une expérience simple, dans laquelle on demandait aux sujets de toucher certaines zones à l'aide d'un stylet, ce que la figure~\ref{fig:fitts} détaille.
	
	\begin{figure}[!htbp]
		\begin{subfigure}[t]{0.58\textwidth}
			\centering
			\includegraphics[width=\textwidth]{figures/ch2/fitts}
			\caption{La première expérience ayant mené Paul Fitts à la  définition empirique de la loi du même nom. Deux triplets de plaques étaient séparés d'une certaine distance. Les sujets devaient, avec leur stylet \og tapoter \fg{} alternativement les deux plaques centrales de chaque triplet, hachurées sur ce schéma, sans toucher les plaques adjacentes. On pouvait faire varier la largeur des plaques ciblées, ainsi que la distance entre elles. Crédit : Paul M. Fitts~\cite{fitts1954information}.}
			\label{fig:fitts}
		\end{subfigure}
		~
		\begin{subfigure}[t]{0.40\textwidth}
			\centering
			\includegraphics[width=\textwidth]{figures/ch2/theta}
			\caption{Angle $\theta$ pris en compte par~\cite{murata2001extending} dans une version étendue de la loi de Fitts, présentée dans l'équation~\ref{eq:murata}. Le disque rouge représente le curseur, tandis que le rectangle vert représente la cible, située à une distance $D$ du curseur, avec sa largeur $W$ et sa hauteur $H$. Crédit : \cite{casallas2015prediction}.}
			\label{fig:theta}
		\end{subfigure}
		\caption{Expérience de Fitts et modèle de Casallas.}
		\label{fig:fittstheta}
	\end{figure}
	
	Paul M. Fitts a pu déduire de cette étude la loi qui porte son nom, et que l'on peut décrire par les équations~\ref{eq:fitts} et~\ref{eq:fittsID}.
	
	\begin{equation}
		\label{eq:fitts}
		T_{M} = a + bID
	\end{equation}
	
	\begin{equation}
		\label{eq:fittsID}
		ID = \log_2\left(\frac{2D}{W} \right)
	\end{equation}
	
	Dans l'équation~\ref{eq:fitts}, $T_{M}$ représente le temps de mouvement, $a$ et $b$ sont des constantes déterminées empiriquement. Dans l'équation~\ref{eq:fittsID}, $ID$ représente l'indice de difficulté, $D$ représente l'amplitude du mouvement, c'est-à-dire la distance entre la cible et le point de départ du mouvement, tandis que $W$ représente la largeur de la cible. La partie la plus intéressante de cette équation est l'indice de difficulté. C'est la seule partie variable, et elle détermine la difficulté de la tâche. Intuitivement, plus l'amplitude du mouvement nécessaire est grande, plus la tâche sera difficile ; plus la largeur de la cible est grande, plus la tâche sera facile. MacKenzie propose une formulation de l'indice de difficulté dite de Shannon, inspirée de la théorie de l'information proposée par ce dernier~\cite{mackenzie1989note}. Cette formulation a l'avantage d'être positive même quand l'amplitude de mouvement est très faible (voir l'équation~\ref{eq:shannon}).
	
	\begin{equation}
		\label{eq:shannon}
		ID = \log_2\left(\frac{D}{W} + 1\right)
	\end{equation}
	
	\subsection{Extensions de la loi de Fitts}
	L'étude de Paul M. Fitts portait sur un dispositif mécanique simple, mais sa loi s'applique aussi bien aux périphériques de saisie classiques (souris, \emph{joysticks}, etc.)~\cite{card1978evaluation}. Mieux, alors qu'elle fut d'abord énoncée pour des mouvements sur une seule dimension, cette loi s'étend aisément au plan~\cite{card1978evaluation, mackenzie1992extending}, éventuellement en tenant compte de la forme de la cible (en distinguant sa largeur $W$ de sa hauteur $H$, avec un coefficient réel $\eta$, cf. l'équation~\ref{eq:accot})~\cite{accot2003refining}, ou même à l'espace tridimensionnel~\cite{ware1997selection, murata2001extending}. Ware \emph{et al.} proposent ainsi une extension 3D d'une version déjà étendue de la loi de Fitts ; nous présentons leur modèle dans l'équation~\ref{eq:ware}, où $largeur$, $hauteur$ et $profondeur$ se rapportent aux dimensions de la cible, assimilée à un parallélépipède rectangle. On peut également généraliser la loi de Fitts pour modéliser des tâches de tracé de trajectoires~\cite{accot1997beyond, accot1999performance}.
	
	\begin{equation}
		\label{eq:accot}
		ID = \log_2\left( \sqrt{ \left( \frac{D}{W} \right) ^2 + \eta \left( \frac{D}{H} \right) ^2}  + 1\right)
	\end{equation}
	
	\begin{equation}
		\label{eq:ware}
		ID = \log_2\left( \frac{D}{min(largeur,hauteur,profondeur)} + 1\right)
	\end{equation}
	
	Bien qu'elle soit d'une élégante simplicité et d'une utilité évidente pour modéliser les performances de sélection, de nombreuses formulations plus ou moins différentes existent, et leurs mérites respectifs font débat~\cite{casallas2015prediction}. Par exemple, certaines extensions tiennent compte de l'angle $\theta$ entre le vecteur qui va du curseur à la cible et un vecteur horizontal orienté vers la droite (cf. la figure~\ref{fig:theta}). C'est le cas de la formulation de Murata et Iwase~\cite{murata2001extending} exposée dans l'équation~\ref{eq:murata}. D'autres versions tiennent compte simultanément de la forme de la cible et de cet angle $\theta$~\cite{appert2008evaluation, grossman2004pointing}.
	
	\begin{equation}
		\label{eq:murata}
		ID = \log_2\left(\frac{D}{W} + 1\right) + c \sin \theta
	\end{equation}
	
	\subsection{Loi de Fitts et cibles mobiles}
	\label{sub:fittsMobile}
	La recherche sur la loi de Fitts appliquée aux cibles mobiles, comparativement aux travaux sur les cibles statiques, est pauvre~\cite{casallas2015prediction}. Elle n'est pas inexistante~\cite{jagacinski1980test, hoffmann1991capture, hajri2011moving} mais limitée, et elle s'intéresse rarement à la nature du mouvement des cibles, surtout quand ce mouvement est imprévisible. Par exemple, les modèles développés dans les travaux de Jagacinski \emph{et al.}~\cite{jagacinski1980test} ou d'Al Harji \emph{et al.}~\cite{hajri2011moving} font l'hypothèse de cibles de vitesse et de direction constantes. La loi de Fitts étendue par Jagacinski \emph{et al.} est présentée dans l'équation~\ref{eq:jagacinski}, où $CT$ est le temps de sélection, $D$, $W$, et $V$ sont la distance à la cible, sa largeur, et sa vitesse, tandis que $c$, $d$ et $e$ sont des constantes réelles.
	
	\begin{equation}
		\label{eq:jagacinski}
		CT = c + dD + e(V + 1) \left(\frac{1}{W} - 1\right)
	\end{equation}
	
	Les travaux d'Al Harji \emph{et al.}~\cite{hajri2011moving} tiennent aussi compte de la direction de la cible ; ils ont développé deux modèles fondés sur ce principe. Le premier est décrit par l'équation~\ref{eq:hajriC2}, où $\vec{F}$ est un vecteur déterminé empiriquement, $\vec{D}$ est le vecteur distance entre le curseur et la cible, $\vec{V}$ est le vecteur de vélocité de la cible, et $\vec{R} = \frac{1}{2} \begin{pmatrix}
	W \\ H \\
\end{pmatrix}$. Le second est défini par l'équation~\ref{eq:hajriVW}, où $f_{W'}(\theta)$ est un paramètre empirique dépendant de $\theta$, l'angle formé par la direction du mouvement de la cible et l'horizontale. De même, $K$ est un paramètre empirique. $D$ est la distance entre le curseur et la cible, $V$ est la vitesse de la cible, et $W'$ est sa largeur dans la direction du mouvement.
	
	\begin{equation}
		\label{eq:hajriC2}
		ID_{C2} = \log_{2}\left(\abs*{\vec{F} \frac{\vec{D}+\vec{V}}{\vec{R}-\vec{V}}} + 1 \right)
	\end{equation}
	
	\begin{equation}
		\label{eq:hajriVW}
		ID_{VWtW'\theta} = \log_{2}\left( f_{W'}(\theta) \left( \frac{D \pm \frac{V}{K}}{\frac{W'}{2} - \frac{V}{K}} \right) \right)
	\end{equation}
	
	Les corrélations entre ces indices de difficulté et les temps de sélection mesurés par Al Hajri \emph{et al.} sont présentées sur la figure~\ref{fig:holdID}, où l'on observe qu'elles sont supérieures à 90~\%{}. Néanmoins, ces travaux ne portent que sur des cibles dont la vitesse et la direction sont constantes. Casallas~\cite{casallas2015prediction} a également développé un modèle de prédiction du temps de sélection pour les cibles mobiles, détaillé dans l'équation~\ref{eq:casallas}, où $MT$ est le temps de mouvement, $a_{V}$, $b_{V}$, $c_{V}$ et $d_{V}$ sont des coefficients dépendant linéairement de la vitesse $V$, $D_{m}$ et $D_{s}$ sont les longueurs des composantes orthogonales de $\vec{D}$, le vecteur du curseur à la cible (voir la figure~\ref{fig:casallas}).
	
	\begin{equation}
		\label{eq:casallas}
		MT = a_{V} + b_{V}\sqrt{D_{s}} +  c_{V}\sqrt{D_{m}} + d_{V} \log_{2} \left( \frac{2D_{m}}{W} \right)
	\end{equation}
	
	Dans une évaluation en 3D, l'auteur observe d'une part que l'effet de la vitesse est plus fort que celui de toutes les autres variables, et d'autre part qu'elle réduit l'écart-type des temps de sélection mesurés quand elle croît. Il mesure même un très bon ajustement de son modèle aux résultats mesurés, avec le coefficient de détermination $R^{2} \in [0,89 ; 0,96]$. Il convient cependant de noter un point très spécifique à cette évaluation : les cibles mobiles se dirigeaient toutes \emph{vers} l'utilisateur --- plus ou moins directement. De fait, l'augmentation de la vitesse \emph{diminue} le temps de sélection, puisqu'elle réduit la distance à parcourir pour l'utilisateur, dans un mouvement rectiligne, donc relativement aisé à prédire et anticiper. Ce résultat au demeurant intéressant ne saurait donc suffire à modéliser les performances de sélection pour les cibles de mouvements quelconques.
	
	\begin{SCfigure}[50][!htbp]
		\centering
		\includegraphics[width=0.24\textwidth]{figures/ch2/casallas}
		\caption[Paramètres du modèle de Casallas]{Modèle de Casallas. $\vec{D}$ est le vecteur du curseur (rouge) à la cible (verte), $\vec{D} = \vec{D_{m}} + \vec{D_{s}}$ où $\vec{D_{m}}$ est la projection de $\vec{V}$ sur $\vec{D}$, et $\vec{D_{s}}$ est la composante de $\vec{D}$ orthogonale à $\vec{D_{m}}$. Crédit : \cite{casallas2015prediction}.}
		\label{fig:casallas}
	\end{SCfigure}
	
	D'autres travaux s'attachent à développer des techniques de sélection de cibles de mouvements quelconques, sans nécessairement s'attarder sur les aspects théoriques~\cite{hasan2011comet, ortega2013hook}, et donc sans chercher à étendre la loi de Fitts. Celle-ci n'a, à notre connaissance, jamais été étendue pour modéliser le temps de sélection de cibles mobiles dont la direction peut changer de façon aléatoire, ce qui la rend d'une utilité discutable pour certaines des applications identifiées plus haut, et particulièrement pour les simulations moléculaires interactives, caractérisées par l'imprévisibilité des mouvements de leurs cibles.
	
	\subsection{Complexité du mouvement : décomposition en sous-mouvements}
	Woodworth~\cite{woodworth1899accuracy} fut à notre connaissance le premier à identifier deux phases dans le mouvement ciblé : une impulsion initiale et une phase de contrôle. Welford~\cite{welford1968fundamentals} fit la même observation et nota par ailleurs que la première phase, visant à couvrir la distance nécessaire, était plus rapide, tandis que la seconde, celle de ciblage, était plus courte~\cite{mackenzie1987three}. Il remarqua de plus, et de même que Crossman et Goodeve~\cite{crossman1983feedback}, que la première phase était \emph{balistique} et qu'à la seconde s'ajoutait un processus de contrôle visuel. Cela s'observe concrètement dans le profil de vitesse d'un curseur en fonction du temps au cours d'un mouvement ciblé, par exemple de sélection. La phase balistique est caractérisée par une forte croissance suivie d'une forte décroissance de la vitesse, dans un profil pouvant rappeler une cloche ; puis la phase de correction suit, et se distingue par de faibles mais potentiellement nombreuses et surtout rapides oscillations, comme l'illustre la figure~\ref{fig:ballistic}.
	
	\begin{figure}[!htbp]
		\centering
		\includegraphics[width=0.50\textwidth]{figures/ch2/ballistic}
		\caption[Profil de vitesse -- phases balistique et de correction]{Vitesse du pointeur en fonction du temps au cours d'un mouvement ciblé. La vitesse croît fortement puis décroît de même au cours de la phase balistique, puis connaît de petites oscillations au cours de la phase de correction. Crédit : \cite{liu2009designing}.}
		\label{fig:ballistic}
	\end{figure}
	
	Langolf \emph{et al.}~\cite{langolf1976investigation} ont de plus montré que \og le mouvement entier vers le centre de la cible devient plus lent quand les tolérances sur la cible (i.e. sa largeur) diminuent \fg{}, ce qui est cohérent avec les travaux de Crossman et Goodeve~\cite{crossman1983feedback}, Marteniuk \emph{et al.}~ \cite{marteniuk1987constraints}, ainsi que ceux de Soechting~\cite{soechting1984effect}. Ce dernier remarqua par ailleurs qu'avec de petites cibles, la phase balistique était plus courte, et de fait la phase de correction en était d'autant rallongée.

	\label{sub:smso}
	Meyer \emph{et al.}~\cite{meyer1988optimality} proposent un modèle des \og sous-mouvements stochastiques optimisés \fg{} (ou SMSO), fondé sur des hypothèses différentes : la phase balistique et la phase de correction ne sont pas considérées comme telles, mais font place à des sous-mouvements successifs, permettant chacun de se rapprocher un peu plus de la cible (voir la figure~\ref{fig:meyer}). Outre le fait que le modèle SMSO permet d'expliquer l'origine de la loi de Fitts, et bien que la quantité de sous-mouvements soit fixée à 2 par les auteurs du modèle --- notamment du fait des travaux de Langolf \emph{et al.}~\cite{langolf1976investigation} et Carlton~\cite{carlton1979control}, qui ont constaté la prépondérance de ce cas de figure --- ils admettent qu'elle peut être plus élevée~\cite{crossman1963feedback, crossman1983feedback}, notamment quand la difficulté de sélection est grande, et en particulier quand le curseur doit rester sur la cible et non se contenter de passer dessus.
	
	\begin{SCfigure}[50][!htbp]
		\centering
		\includegraphics[width=0.5\textwidth]{figures/ch2/meyer}
		\caption[Profils de vitesse et d'accélération dans le modèle SMSO]{Profils de vitesse et d'accélération dans le modèle SMSO. Les unités sont en dégrés d'angle, car le mouvement étudié par Meyer \emph{et al.} était rotatif. Crédit : \cite{meyer1988optimality}.}
		\label{fig:meyer}
	\end{SCfigure}
	
	Dans ce dernier cas, étudié par Jagacinski \emph{et al.}~\cite{jagacinski1980fitts}, les cibles étaient statiques. Pourtant, lorsque l'ID était élevé, le nombre de sous-mouvements pouvait atteindre quatre. Dans un cas similaire mais avec des cibles mobiles, ce nombre pourrait être (beaucoup) plus élevé. Nous reviendrons donc plus loin sur la pertinence de l'interprétation d'un mouvement de sélection de cible mobile en succession (potentiellement longue) de sous-mouvements, en nous appuyant sur ces travaux. La conclusion générale de ces diverses études et propositions théoriques est que la précision requise par un mouvement influe non seulement sur son temps global de complétion, mais également sur l'ensemble de la trajectoire, et notamment sur le profil de vitesse du curseur en fonction du temps. Dès lors, nous pouvons formuler l'hypothèse que les difficultés inhérentes à la sélection de cibles mobiles constituent un besoin accru de précision, et que par conséquent, un effet spécifique pourra être observé sur les trajectoires des curseurs. Plus précisément, nous pouvons formuler l'hypothèse que la mobilité d'une cible mène à une multiplication des sous-mouvements.
	
\section{Taxinomie des techniques de sélection}
	Dans les sections suivantes, nous présenterons un échantillon représentatif de techniques de sélection de cibles, statiques et mobiles. Cette présentation sera structurée selon la taxinomie dont un schéma est fourni sur la figure~\ref{fig:selTaxi}, et dont les critères et catégories seront explicités le long des sections suivantes. À la fin du chapitre, un retour global et plus détaillé sur cette taxinomie sera proposé.	
	
\begin{landscape}
	\begin{figure}
		\centering
		\includegraphics[width=\linewidth]{figures/ch2/selTechTree}
		\caption[Taxinomie des techniques de sélection de cibles]{Notre proposition de taxinomie des techniques de sélection de cibles. Les catégories et sous-catégories sont représentées par des rectangles arrondis de couleur rose pâle, et les techniques de sélection sont représentées par les rectangles bleus/verts. Une technique peut appartenir à différentes catégories à la fois, comme \emph{IntenSelect}, par exemple.}
		\label{fig:selTaxi}
	\end{figure}
\end{landscape}
	
\section{Techniques pour la sélection de cibles statiques}
	Commençons par examiner les techniques conçues pour améliorer les performances de sélection de cibles statiques, mais précisons au préalable qu'elles sont toutes utilisables avec des cibles mobiles, avec divers degrés d'efficacité. Certaines techniques anciennes mais fondatrices sont décrites dans l'annexe~\ref{appendix:annexeC} ; la présente section se contente de les mentionner, pour référence.

\subsection{Curseurs zonaux}
	Un curseur zonal substitue au curseur ordinaire, qui est réduit à un point, une zone de sélection~\cite{kabbash1995prince, worden1997making}. Lorsque la cible est petite, les performances de sélection ne sont donc plus limitées par sa taille, mais par la taille du curseur. De plus, la distance à parcourir par le curseur zonal pour atteindre la cible est légèrement réduite, puisqu'il faut la mesurer à partir de la limite de la zone de sélection, et non depuis son centre.
	
	Les techniques \emph{Prince}, \emph{Area Cursor}, et \emph{Silk Cursor} sont décrites dans les sections~\ref{sub:prince}, \ref{sub:areaCursor}, et~\ref{sub:silkCursor}, respectivement.

	\subsubsection{\emph{Bubble Cursor}}
	La technique \emph{Bubble Cursor} consiste à agrandir dynamiquement un curseur zonal (représenté par un disque) jusqu'à ce qu'il atteigne la cible la plus proche. Mathématiquement, cela revient à construire un diagramme de Voronoï des cibles et à s'appuyer dessus pour la sélection : le \emph{Bubble Cursor} est toujours dans une et une seule cellule du diagramme, et peut sélectionner la cible correspondante, comme l'illustrent les figures~\ref{fig:bubble} et~\ref{fig:voronoi}. De fait, dans sa version pure, il n'est capable de sélectionner que des cibles, pas l'espace entre celles-ci.	

	\begin{figure}[htbp]
		\begin{subfigure}[t]{0.45\textwidth}
			\centering
			\includegraphics[width=\textwidth]{figures/ch2/bubble}
			\caption{(a,b) : un curseur zonal ne permet pas de choisir entre deux cibles dans sa zone de sélection, mais le \emph{Bubble Cursor} s'adapte (c et d). (d) : la cible n'est pas \emph{entièrement} recouverte par le disque du curseur, qui est localement étendu pour l'envelopper.}
			\label{fig:bubble}
		\end{subfigure}
		~
		\begin{subfigure}[t]{0.53\textwidth}
			\centering
			\includegraphics[width=\textwidth]{figures/ch2/voronoi}
			\caption{Diagramme de Voronoï : pavage du plan en cellules à partir d'un ensemble discret de points (\emph{germes}). Chaque cellule forme l'ensemble des points plus proches de son germe que des autres. La largeur effective d'une cible est celle de sa cellule.}
			\label{fig:voronoi}
		\end{subfigure}
		\caption[\emph{Bubble Cursor}]{\emph{Bubble Cursor}. Crédit : \cite{grossman2005bubble}.}
		\label{fig:bubbleVoronoi}
	\end{figure}
	
	\begin{SCfigure}[50][htbp]
		\centering
		\includegraphics[width=0.42\textwidth]{figures/ch2/bubbleResults}
		\caption[\emph{Bubble Cursor} --  performances]{Temps de pointage avec et sans le \emph{Bubble Cursor}, en fonction de $W$ et $EW$, où $W$ est la largeur réelle de la cible, et $EW$ sa largeur effective. Le \emph{Bubble Cursor} améliore les performances, dépend de $EW$ bien plus que de $W$. Crédit : \cite{grossman2005bubble}.}
		\label{fig:bubbleResults}
	\end{SCfigure}
	
	Grossman et Balakrishnan ont montré que les performances de sélection avec le \emph{Bubble Cursor} suivent la loi de Fitts, à condition de remplacer la largeur de la cible par sa largeur effective, c'est-à-dire la largeur de sa cellule dans le diagramme de Voronoï~\cite{grossman2005bubble}, cf. la figure~\ref{fig:bubbleResults}. Le \emph{Bubble Cursor} peut être mis en œuvre en 2D aussi bien qu'en 3D~\cite{vanacken2007exploring}.

	\paragraph{Instabilité.}
	Un inconvénient de cette technique est le fait que le curseur peut rapidement croître et décroître à mesure qu'il s'approche et s'éloigne de plusieurs cibles successives. Cela peut représenter une source de distraction visuelle, en particulier quand les cibles elles-mêmes sont mobiles, \emph{a fortiori} si elles sont rapides. De plus, attendu que le \emph{Bubble Cursor} agrandit la largeur effective des cibles à la mesure de leur cellule de Voronoï, il est moins efficace en environnement dense, où les cellules de Voronoï sont plus petites. Le \emph{Bubble Cursor} montre donc ses limites face à des cibles potentielles nombreuses, mobiles et rapides. Par ailleurs, un environnement dynamique impose un calcul coûteux~\cite{aurenhammer2000voronoi} de diagramme de Voronoï à chaque déplacement d'un objet.
	
	Un autre inconvénient du \emph{Bubble Cursor} est intrinsèquement lié à son mode de fonctionnement : il partage l'espace de sélection en un diagramme de Voronoï, où tout point de l'espace fait partie de la zone de sélection d'une cible. Par conséquent, il n'existe plus d'espace \og vide \fg{} dans lequel on pourrait utiliser le périphérique de saisie pour effectuer une opération indépendante des cibles, par exemple ouvrir un menu contextuel.

	\subsubsection{\emph{DynaSpot}}
	L'impossibilité de sélectionner l'espace vide avec le \emph{Bubble Cursor} est une des raisons d'être de la technique \emph{DynaSpot}~\cite{chapuis2009dynaspot}. Celle-ci relie l'aire du curseur à sa vitesse. Le curseur conserve sa taille normale lorsqu'il est lent, mais croît et affecte une plus grande surface quand il se déplace plus vite. De fait il suffit de ralentir pour ramener le curseur à un comportement \og normal \fg{} et pouvoir sélectionner de l'espace vide, par exemple pour ouvrir un menu contextuel, comme l'illustre la figure~\ref{fig:dynaSpot}.
	
	\begin{figure}[htbp]
		\begin{subfigure}[t]{0.54\textwidth}
			\centering
			\includegraphics[width=\textwidth]{figures/ch2/dynaSpot}
			\caption{(a) Le curseur de \emph{DynaSpot} croît avec la vitesse du curseur. (b) Plusieurs objets coupent la zone de sélection : la cible la plus proche du curseur est sélectionnée. (c) Quand le curseur ne touche aucun objet, on peut sélectionner l'espace vide.}
			\label{fig:dynaSpot}
		\end{subfigure}
		~
		\begin{subfigure}[t]{0.44\textwidth}
			\centering
			\includegraphics[width=\textwidth]{figures/ch2/dynaResults}
			\caption{Temps de sélection du \emph{BubbleCursor}, de deux versions de \emph{DynaSpot}, et d'un curseur ponctuel, en fonction de l'ID (calculé en fonction de la largeur effective pour le \emph{Bubble Cursor} et \emph{DynaSpot}.}
			\label{fig:dynaResults}
		\end{subfigure}
		\caption[\emph{DynaSpot} -- principe et performances]{\emph{DynaSpot} -- principe et performances. Crédit : \cite{chapuis2009dynaspot}.}
		\label{fig:dynaSpotRes}
	\end{figure}
	
	Il n'est donc pas nécessaire de désactiver \emph{DynaSpot} ou de changer de mode explicitement. En ceci, \emph{DynaSpot} comble une des lacunes du \emph{Bubble Cursor}. Cependant, Chapuis \emph{et al.}~\cite{chapuis2009dynaspot} ont montré que dans la plupart des cas, les performances de \emph{DynaSpot} sont similaires à celles du \emph{Bubble Cursor}. Ces résultats sont résumés dans la figure~\ref{fig:dynaResults}.

	Attendu que la croissance et la décroissance du curseur sont à la fois lentes et prévisibles avec cette technique, le niveau de distraction visuelle est faible. Par ailleurs, il n'est pas nécessaire de connaître la position des cibles potentielles pour appliquer \emph{DynaSpot}, qui ne dépend que de la vitesse du curseur. En cela, cette technique permet de pallier deux autres inconvénients du \emph{Bubble Cursor}.

	\paragraph{Ambiguïté et ralentissements.}
	Le principal inconvénient de cette technique est précisément le fait que le curseur ne tient pas compte des cibles. Par conséquent, à vitesse élevée, sa surface peut en recouvrir plusieurs, et il ne peut déterminer laquelle est la bonne. Il est donc nécessaire de ralentir et d'attendre que le curseur rapetisse suffisamment pour ne toucher qu'une cible. En pratique, cela se produit assez rapidement, et pour les cibles statiques ce n'est pas vraiment gênant. Mais si les cibles sont mobiles, et \emph{a fortiori} rapides, le curseur ne peut s'arrêter, et il peut même être impossible à l'utilisateur de ralentir suffisamment pour que le curseur retrouve une taille permettant la sélection. Ainsi, de même que pour le \emph{Bubble Cursor}, la densité et la vitesse des cibles posent de sérieux problèmes. On pourrait toutefois envisager une sélection en deux temps (en cascade) : l'utilisateur pré-sélectionnerait plusieurs cibles lorsque le curseur est gros et rapide, puis devrait choisir parmi les cibles touchées laquelle il veut --- avec les inconvénients inhérents à ce type de procédé, comme nous le détaillons dans la section~\ref{sub:cascade}.
	
	%. Naturellement, le processus de sélection en deviendrait plus lourd et plus long, et pourrait nécessiter de stopper (ou ralentir) les cibles après l'étape de pré-sélection pour que la sélection finale soit réalisable, ou bien encore de zoomer fortement sur l'espace pré-sélectionné. Cette dernière solution semble intéressante, mais peut s'avérer peu pratique si les cibles de l'espace pré-sélectionné ont des directions opposées et sont suffisamment rapides pour forcer un \og dézoom \fg{} avant que la sélection finale ne puisse avoir lieu.

	\subsubsection{La densité : un écueil pour les curseurs zonaux}
	Le principal inconvénient d'un curseur zonal se présente lorsque la densité de cibles potentielles est élevée. Si deux cibles sont séparées d'une distance inférieure à la taille de la zone de sélection, il peut être difficile de choisir parmi les deux. Ce problème est illustré par la figure~\ref{fig:bubble}. Il est possible de partiellement le pallier en utilisant une zone plus petite, mais en plus de réduire l'efficacité de la technique, ce n'est certain de fonctionner que si l'on connaît \emph{a priori} la distance minimale entre deux cibles. La figure~\ref{fig:areaCursor} présente une solution possible, qui consiste à n'utiliser que le centre du curseur, mais cela implique la perte de l'avantage fourni par un curseur zonal.
	
	\subsection{Techniques de lancer de rayon (\emph{raycasting})}
	\label{sec:raycasting}
	Certaines techniques substituent aux curseurs classiques des rayons ou volumes projetés depuis un point contrôlé par l'utilisateur. Nous allons ici les examiner ensemble.

	\subsubsection{Lancer de rayon (\emph{raycasting}) pur}
	Le \emph{raycasting} est une technique de sélection conceptuellement très simple : un périphérique est utilisé pour lancer un rayon virtuel, généralement le long d'un axe du périphérique. Le rayon peut ensuite croiser un objet, ce qui permet de le sélectionner. Cette technique est parfois appelée \emph{laser gun}~\cite{liang1994jdcad}, et elle est illustrée par la figure~\ref{fig:dCanvas2}. Elle a plusieurs avantages : elle permet de sélectionner un objet à n'importe quelle distance, sans avoir à se déplacer ; on peut sélectionner un objet très éloigné de la position initiale du curseur sans avoir à faire de grand mouvement, puisqu'il suffit de changer l'orientation du périphérique de pointage, donc d'un simple mouvement de poignet.
	
	Cependant, pour les objets de petite taille apparente, la sélection peut être difficile, car elle requiert une précision angulaire élevée. De plus, si le système de \emph{tracking} qui fournit la position et l'orientation du périphérique de pointage produit un signal bruité, la difficulté de sélection s'en trouve encore accrue~\cite{argelaguet2013survey}. Par conséquent, des techniques dérivées du \emph{raycasting} ont été développées. Classiquement, on utilisera une technique de cône de sélection, comme par exemple \emph{Spotlight}~\cite{liang1994jdcad}, illustrée par la figure~\ref{fig:spotlight}. Comme le nom l'indique, les techniques de ce type remplacent le rayon de sélection par un cône dont le sommet est placé sur le périphérique de pointage. Cela facilite la sélection, puisque les gestes n'ont plus besoin d'être aussi précis, mais peut ajouter de l'ambiguïté si deux objets se trouvent dans le cône de sélection. Le cas échéant, cette ambiguïté peut être levée de plusieurs façons, en fonction de la proximité à l'axe de révolution du cône, en fonction de la distance au périphérique de pointage, ou via une intervention directe de l'utilisateur.
	
	\begin{SCfigure}[50][htbp]
		\centering
		\includegraphics[width=0.44\textwidth]{figures/ch2/spotlight}
		\caption[Cône de sélection : \emph{Spotlight}]{\emph{Spotlight} : les objets dans le cône sont des candidats à la sélection ; quand il y en a plusieurs, le plus proche de l'axe de révolution du cône est choisi, et en cas de proximité égale, le plus proche du périphérique de pointage est choisi. Crédit : \cite{liang1994jdcad}.}
		\label{fig:spotlight}
	\end{SCfigure}
	
	Le choix de l'angle du cône est important : plus il est grand, plus la sélection est facile mais potentiellement ambiguë, et inversement. Cet angle peut éventuellement être paramétrable, permettant à l'utilisateur de choisir ce qui lui convient le mieux, voire de l'ajuster à la volée en cours d'utilisation. Cet ajustement pourrait également être géré automatiquement par le système interactif, par exemple de façon analogue à ce qui est fait avec des pointeurs classiques dans le \emph{Bubble Cursor}~\cite{grossman2005bubble} ou \emph{DynaSpot}~\cite{chapuis2009dynaspot}.
	
	\subsubsection{\emph{Shadow Cone}}
	Le \emph{Shadow Cone}~\cite{steed20043d} est une technique développée spécifiquement pour les \emph{spatially immersive displays} (SID) tels que les CAVE. L'idée est de permettre non seulement une sélection performante dans des conditions \og normales \fg{} mais également de sélectionner des objets lorsque l'utilisateur n'est pas suivi par le SID, et que le rendu n'est pas adapté à sa position, donc incorrect. Steed et Parker~\cite{steed20043d} identifient ce besoin en partant du constat qu'un SID ne permet généralement de suivre et d'adapter le rendu graphique qu'à une seule personne (mais pas toujours\footnotemark), ce qui implique qu'un deuxième utilisateur ne peut bénéficier d'un rendu adapté, et rencontrera donc des difficultés pour accomplir des tâches collaboratives nécessitant une étape de sélection.
	
	\footnotetext{Le système EVE (Environnement Virtuel Evolutif), permet d'étudier à la fois les aspects multisensoriels et collaboratifs des interactions humaines au sein de mondes virtuels. Les spécificités du système EVE, comme ses dimensions très grandes, une stéréoscopie multi-utilisateurs haute qualité, des rendus haptiques et audio 3D, en font un dispositif unique dans le domaine de la réalité virtuelle.
	\url{https://www.limsi.fr/index.php/fr/recherche/venise/menuitem-venise-demos-fr}}
	
	Le \emph{Shadow Cone} fonctionne comme un cône de sélection, mais avec une désambiguïsation explicite : lorsque l'utilisateur presse le bouton de son périphérique de pointage, tous les objets dans le cône sont pré-sélectionnés ; puis, l'utilisateur déplace le périphérique et son cône, de telle sorte que certains des objets pré-sélectionnés ne sont plus dans le cône. Dès lors qu'ils en sortent, ils ne sont plus pré-sélectionnés, et aucun objet n'est ajouté à la pré-sélection. Quand l'utilisateur relâche le bouton de son périphérique, tous les objets se trouvant encore dans le cône et l'ayant toujours été sont sélectionnés (voir la figure~\ref{fig:shadow}).
	
	\begin{figure}[!htbp]
		\centering
		\includegraphics[width=0.9\textwidth]{figures/ch2/shadow}
		\caption[Fonctionnement du \emph{Shadow Cone}]{\emph{Shadow Cone}. (a) Sélection par \emph{raycasting} classique : le premier objet croisé par le rayon est sélectionné (A ici). (b) Sélection par cône : l'objet le plus proche de l'axe de révolution du cône est sélectionné (D ici). (c) \emph{Shadow Cone} : l'objet sélectionné est celui qui est inclus dans le cône de sélection à tous les instants entre la pression du bouton du périphérique et son relâchement (G ici). Crédit : \cite{steed20043d}.}
		\label{fig:shadow}
	\end{figure}
	
	\paragraph{Performances.}
	Steed et Parker ont évalué les temps de sélection du \emph{Shadow Cone}, comparé à la sélection par rayon ou par cône. Pour les différentes techniques, avec et sans suivi de la tête, ils sont présentés sur les figures~\ref{fig:shadowSLarge} (grande cible), \ref{fig:shadowSSmall} (petite cible), \ref{fig:shadowPLarge} (grande cible avec distracteur), \ref{fig:shadowPSmall} (petite cible avec distracteur), \ref{fig:shadowCLarge} (grande cible avec de nombreux distracteurs), et enfin \ref{fig:shadowCSmall} (petite cible avec de nombreux distracteurs). Nous ne commentons ici que les résultats avec suivi de la tête, attendu que le cas particulier de rendu immersif incorrect dépasse le cadre de cet état de l'art et des applications identifiés au cours du chapitre~\ref{chap1}. Observons simplement que pour une condition et une technique données, le suivi de la tête améliore presque toujours les temps de sélection, les erreurs et les échecs.

	\newcommand{\subImgWmo}{0.315\textwidth}
	\begin{figure}[!htbp]
		\begin{subfigure}[t]{\subImgWmo}
			\centering
			\includegraphics[width=\textwidth]{figures/ch2/shadowSLarge}
			\caption{Grande cible.}
			\label{fig:shadowSLarge}
		\end{subfigure}
		~
		\begin{subfigure}[t]{\subImgWmo}
			\centering
			\includegraphics[width=\textwidth]{figures/ch2/shadowSSmall}
			\caption{Petite cible.}
			\label{fig:shadowSSmall}
		\end{subfigure}
		~
		\begin{subfigure}[t]{\subImgWmo}
			\centering
			\includegraphics[width=\textwidth]{figures/ch2/shadowPLarge}
			\caption{2 grands objets. \emph{Ray} : 0 erreur ; 1,3 erreur/utilisateur pour \emph{Cone}, 0,2 pour \emph{SCone}.}
			\label{fig:shadowPLarge}
		\end{subfigure}
		~
		\begin{subfigure}[t]{\subImgWmo}
			\centering
			\includegraphics[width=\textwidth]{figures/ch2/shadowPSmall}
			\caption{2 petits objets. \emph{SCone} : 0,2 erreur/utilisateur vs. 0,6 pour \emph{Cone}, et 0 pour \emph{Ray}.}
			\label{fig:shadowPSmall}
		\end{subfigure}
		~
		\begin{subfigure}[t]{\subImgWmo}
			\centering
			\includegraphics[width=\textwidth]{figures/ch2/shadowCLarge}
			\caption{Gros objets. \emph{Cone} : 2,2 échecs par \emph{timeout} et 20,3 erreurs par utilisateur. \emph{SCone} 5,2 erreurs, 0 échec. \emph{Ray} 0,5 échec, 0 erreur.}
			\label{fig:shadowCLarge}
		\end{subfigure}
		~
		\begin{subfigure}[t]{\subImgWmo}
			\centering
			\includegraphics[width=\textwidth]{figures/ch2/shadowCSmall}
			\caption{Petits objets. \emph{Cone} : 4,4 erreurs et 2 échecs par utilisateur. \emph{SCone} : 4,5 erreurs, 0 échec. \emph{Ray} : 1,2 échec, 0 erreur.}
			\label{fig:shadowCSmall}
		\end{subfigure}
		\caption[Performances du \emph{Shadow Cone}]{Performances du \emph{Shadow Cone (SCone)}, de la sélection par cône (\emph{Cone}) et par lancer de rayon (\emph{Ray}). Chaque technique est évaluée avec suivi de la tête (en bleu) et sans (en violet). Erreurs rapportées pour les conditions avec suivi. Crédit : \cite{steed20043d}.}
		\label{fig:shadowConePerf}
	\end{figure}
	
	\subsubsection{Le problème de l'ambiguïté en environnement dense}
	Lorsque l'environnement est particulièrement dense, la sélection par rayon ou cône devient difficile~\cite{kopper2011rapid}, car la précision requise devient très élevée, tant pour l'utilisateur que pour le système de suivi du périphérique de pointage. L'utilisation d'un cône facilite la sélection de petites cibles, mais ajoute un risque d'ambiguïté. Une solution pourrait être d'augmenter le ratio contrôle/affichage à proximité des cibles~\cite{frees2007prism, kopper2010human}, mais au prix de l'introduction d'un décalage entre l'orientation réelle du périphérique de pointage et celle du rayon lancé, ce qui peut être très troublant, et peu performant avec des cibles mobiles, surtout rapides.
	
	Et si diverses techniques peuvent aider à lever l'ambiguïté, leur utilisation est d'autant plus difficile que les cibles situées dans le volume du cône sont nombreuses, petites et\ldots{} mobiles. En effet, la mobilité des cibles nécessite d'effectuer des mouvements plus rapides pour les pointer, donc d'exercer plus de force, et de fait, d'être moins précis~\cite{schmidt1979motor}. En particulier, le \emph{Shadow Cone} impose de maintenir la cible visée à l'intérieur du cône pendant toute la phase de désambiguïsation, ce qui peut s'avérer extrêmement difficile avec une cible en mouvement, \emph{a fortiori} si ses mouvements sont rapides et/ou imprévisibles. Par conséquent, nous ne pouvons retenir cette technique pour les applications qui nous intéressent. Mais en assouplissant cette contrainte, le \emph{Shadow Cone} fournirait potentiellement de meilleurs résultats avec des cibles mobiles. C'est en substance ce que propose le \emph{Smart Ray}~\cite{grossman2006design}, décrit plus bas.

	\subsection{\emph{Raycasting} avec désambiguïsation}
	Grossman \emph{et al.}~\cite{grossman2006design} proposent d'évaluer diverses techniques de sélection dérivées du \emph{raycasting} et ayant pour but de faciliter la désambiguïsation lorsque le rayon atteint plusieurs objets. Ces travaux sont présentés comme étant motivés par l'émergence d'écrans volumétriques\footnotemark{}~\cite{ebert1999realizing}, mais demeurent très pertinents pour des dispositifs d'affichage plus classiques, notamment stéréoscopiques.
	
	\footnotetext{Un écran volumétrique est un dispositif formant une représentation en 3D des objets qu'il affiche, généralement via une forme d'autostéréoscopie, c'est-à-dire de stéréoscopie ne nécessitant pas le port de lunettes spéciales.}

	\subsubsection{\emph{Depth Ray}}
	Le \emph{Depth Ray}~\cite{grossman2006design} fonctionne comme une technique de \emph{raycasting} traditionnelle, si ce n'est que la position du périphérique le long de son axe de pointage est prise en compte, comme le montre la figure~\ref{fig:depthRay}. Le rayon est ainsi augmenté d'un marqueur de profondeur que l'utilisateur déplace le long du rayon simplement en avançant ou en reculant le périphérique de pointage.
	
	\newcommand{\rayWidth}{0.48\textwidth}
	\newcommand{\rayImgWidth}{0.7\textwidth}
	\begin{figure}[htbp]
		\begin{subfigure}[t]{\rayWidth}
			\centering
			\includegraphics[width=\rayImgWidth]{figures/ch2/depthRay}
			\caption{\emph{Depth Ray}. (a) Un marqueur rose sélectionne la cible intersectée la plus proche de lui. (b) Reculer le périphérique de pointage recule le marqueur et permet de séletionner une cible plus proche\ldots{} et inversement (c).}
			\label{fig:depthRay}
		\end{subfigure}
		~
		\begin{subfigure}[t]{\rayWidth}
			\centering
			\includegraphics[width=\rayImgWidth]{figures/ch2/lockRay}
			\caption{\emph{Lock Ray}. (a) Première phase : \emph{raycasting} classique. (b) Après pression du bouton du périphérique, un marqueur de profondeur apparaît. (c) L'utilisateur le déplace avec sa main, et sélectionne en relâchant le bouton.}
			\label{fig:lockRay}
		\end{subfigure}
		~
		\begin{subfigure}[t]{\rayWidth}
			\centering
			\includegraphics[width=\rayImgWidth]{figures/ch2/flowerRay}
			\caption{\emph{Flower Ray}. (a) Toutes les cibles croisées par le rayon sont en vert. (b) Sur une pression de bouton, elles s'épanouissent en un menu de sélection autour d'un curseur qui apparaît alors. (c) L'utilisateur pointe près de la cible et relâche le bouton pour la sélectionner.}
			\label{fig:flowerRay}
		\end{subfigure}
		~
		\begin{subfigure}[t]{\rayWidth}
			\centering
			\includegraphics[width=\rayImgWidth]{figures/ch2/smartRay}
			\caption{\emph{Smart Ray}. Sélection du carré. (a) Les poids des cibles dépendent de leur distance au rayon (illustrés par des sphères dans les cibles). La cible de poids maximal peut être sélectionnée. (b,c) Le rayon peut être repositionné pour augmenter le poids de la cible visée.}
			\label{fig:smartRay}
		\end{subfigure}
		\caption[Lancer de rayon avec désambiguïsation]{Techniques de lancer de rayon avec désambiguïsation. Crédit : \cite{grossman2006design}.}
		\label{fig:depthLockFlowerSmartRays}
	\end{figure}
	
	\subsubsection{\emph{Lock Ray}}
	Le \emph{Lock Ray}~\cite{grossman2006design} fonctionne de la même façon que le \emph{Depth Ray}, si ce n'est qu'une fois que le rayon est positionné, il est \emph{verrouillé} --- d'où le nom --- afin de permettre à l'utilisateur de déplacer le marqueur de profondeur sans avoir à craindre de faire bouger le rayon par accident.
	
	\subsubsection{\emph{Flower Ray}}
	Comme le \emph{Lock Ray}, le \emph{Flower Ray}~\cite{grossman2006design} fonctionne avec deux phases distinctes. Dans la première, l'utilisateur place son rayon dans la position et l'orientation qu'il désire ; puis, il le fixe, et les objets croisés par le rayon \og s'épanouissent \fg{}  --- tout autour d'un curseur ponctuel, comme les pétales d'une fleur autour de son pistil, ainsi que l'illustre la figure~\ref{fig:flowerRay}. Dans le menu \og floral \fg{} les objets sont disposés par ordre de profondeur croissante dans le sens horaire, avec le plus proche en haut à droite.
		
	\subsubsection{\emph{Smart Ray}}
	Un rayon contient une infinité de points, mais si deux sont sécants, alors ils n'ont qu'un seul point en commun. Il est donc possible d'utilier deux rayons pour effectuer une sélection par \emph{raycasting} sans ambiguïté. Toutefois, cela nécessite deux périphériques de saisie, et occupe les deux mains de l'utilisateur.	Le \emph{Smart Ray}~\cite{grossman2006design} propose donc de faire cela avec deux rayons issus du même périphérique, mais mesurés à deux instant différents, selon un principe proche de celui du \emph{Shadow Cone}~\cite{steed20043d}. Chaque objet se voit attribuer un \og poids \fg{} qui croît d'autant plus que le rayon est proche de son centre, ou décroît d'autant plus qu'il en est loin, continuellement. L'objet dont le poids est le plus élevé peut être sélectionné (voir la figure~\ref{fig:smartRay}).
	
	\subsubsection{Motivations}
	Grossman \emph{et al.}~\cite{grossman2006design} notent que les techniques présentées ci-dessus ont chacune des avantages et des inconvénients. Le \emph{Depth Ray} unifie les phases de sélection et de désambiguïsation, ce qui peut faire gagner du temps mais aussi causer des perturbations entre les phases. Le \emph{Lock Ray} sépare les phases explicitement, mais désambiguïse avec un menu linéaire. Le \emph{Flower Ray} propose un menu radial, théoriquement plus rapide, mais les utilisateurs doivent suivre l'animation pour ne pas perdre leur cible entre les deux phases. Enfin, le \emph{Smart Ray} fournit un mode de désambiguïsation implicite et possiblement plus fluide, mais potentiellement source de frustration s'il échoue à prédire correctement l'intention de l'utilisateur, comme toujours avec les techniques prédictives.
	
	\subsubsection{Évaluations}
	Avec ces mérites respectifs en tête, Grossman \emph{et al.} ont évalué ces quatre techniques dans un environnement dense, afin de rendre la désambiguïsation absolument nécessaire. De fait, la sélection par \emph{raycasting} classique est impossible, et donc ne fut pas évaluée ici. La technique de base considérée est donc le curseur ponctuel. Le curseur ponctuel offre de très bonnes performances par rapport aux techniques de \emph{raycasting}, ce qui peut surprendre compte tenu des performances généralement supérieures de ces dernières~\cite{bowman2001testbed}. Mais le niveau d'occultation avec de nombreux distracteurs est tel que les  performances de cette classe de techniques chutent. Toutefois, le  \emph{Depth Ray} fournit de très bons résultats, meilleurs que ceux du curseur ponctuel. Il profite selon toute probabilité de l'intégration des phases de sélection et de désambiguïsation. Grossman \emph{et al.} remarquent au passage que le temps de désambiguïsation du \emph{Flower Ray} est relativement constant en fonction de l'emplacement de la cible, alors que celui du \emph{Lock Ray} varie beaucoup ; sans doute le menu radial du premier a-t-il un effet lissant sur cette valeur.


	\paragraph{Temps de sélection.}
	
	Les temps de sélection mesurés par les auteurs pour les différentes techniques sont représentés sur la figure~\ref{fig:rayTimes}.
	
	\begin{figure}[!htbp]
		\begin{subfigure}[t]{0.42\textwidth}
			\centering
			\includegraphics[width=\textwidth]{figures/ch2/rayTimes}
			\caption{Seul le \emph{Depth Ray} se montre avantageux.}
			\label{fig:rayTimes}
		\end{subfigure}
		~
		\begin{subfigure}[t]{0.56\textwidth}
			\centering
			\includegraphics[width=\textwidth]{figures/ch2/smartRayLocation}
			\caption{Performances en fonction de l'emplacement des cibles.}
			\label{fig:smartRayLocation}
		\end{subfigure}
		\caption[Performances du \emph{raycasting} avec désambiguïsation]{Performances du \emph{raycasting} avec désambiguïsation. Crédit : \cite{grossman2006design}.}
		\label{fig:rayPerf}
	\end{figure}

	\paragraph{Performances selon l'emplacement de la cible.}
	Les performances du \emph{Smart Ray} paraissent décevantes. Il y a une forte interaction entre le temps de sélection et l'emplacement de la cible avec cette technique (voir la figure~\ref{fig:smartRayLocation}). Pour les cibles situées à droite, les performances s'effondrent, car le rayon part également de la droite (tous les sujets étant droitiers) donc rencontre beaucoup d'obstacles. Dans ces conditions, l'heuristique de prédiction du \emph{Smart Ray} échoue plus souvent. Ces mauvais résultats du \emph{Smart Ray} sont toutefois à nuancer, puisque les sujets avaient pour instruction de ne pas bouger leurs pieds ; s'ils avaient pu se déplacer, les résultats auraient probablement été meilleurs, à condition que leur temps de déplacement ne soit pas trop long.
	
	\paragraph{Distance parcourue par le périphérique.}
	Les auteurs ont par ailleurs mesuré la distance parcourue par le périphérique de pointage au cours d'une tâche de sélection, pour chaque technique évaluée. C'est un résultat important car il est déterminant pour la fatigue ressentie par un utilisateur sur une durée significative. Ici encore, le \emph{Smart Ray} déçoit, tandis que les autres techniques permettent de réduire la distance à parcourir par rapport au curseur ponctuel, comme l'illustre la figure~\ref{fig:rayFootprint}. Là encore, on peut s'interroger sur la solidité des distances mesurées sur \emph{Smart Ray} attendu que dans un contexte \og réel \fg{} les utilisateurs seraient libres de se déplacer. Naturellement, la quantité de mouvement absolue du pointeur pourrait s'en trouver accrue, mais sa quantité de mouvement relatif à l'utilisateur pourrait diminuer. Il resterait à déterminer s'il est plus fatigant de bouger beaucoup son bras, ou un peu son corps et un peu son bras.
	
	\paragraph{Taux d'erreurs.}
	Enfin, Grossman \emph{et al.} rapportent que les taux d'erreurs sont avantageux avec ces techniques de \emph{raycasting} avec désambiguïsation (voir le tableau~\ref{tab:rayErrors}).
	
%	\newcommand{\newrow}{\bigstrut[t] \\ \hline}
	\begin{table}[htbp]
	\centering
	\begin{tabular}{c c c c c c}
		Technique		& Curseur ponctuel	& \emph{Depth}	& \emph{Lock}	& \emph{Flower}	& \emph{Smart}	\\ \hline
		Taux d'erreurs	& 20,7~\%{}			& 13,3~\%{}			& 11,1~\%{}			& 10,9~\%{}			& 10,4~\%{}			\bigstrut[t] \\
	\end{tabular}
	\caption[Taux d'erreurs pour les techniques de \emph{raycasting} avec désambiguïsation]{\emph{Raycasting} avec désambiguïsation et erreurs. Source :~\cite{grossman2006design}.}
	\label{tab:rayErrors}
	\end{table}
	
	\subsubsection{Conclusion}
	L'étude de Grossman \emph{et al.}~\cite{grossman2006design} montre qu'en environnement dense, la sélection par \emph{raycasting} pur est moins efficace qu'un curseur ponctuel, voire impossible, mais que des méthodes de désambiguïsation peuvent permettre d'atteindre de meilleures performances, surtout sur les taux d'erreurs. Le \emph{Depth Ray} se distingue particulièrement avec de très bons temps de sélection, et un taux d'erreurs légèrement plus élevé que ceux des autres techniques évaluées, quoique nettement inférieur à celui d'un curseur ponctuel. Il souffre toutefois d'un léger inconvénient : il nécessite un périphérique de pointage permettant de capturer non seulement son orientation, mais également sa position, c'est-à-dire qu'un simple gyroscope est insuffisant. Ce n'est pas le cas du \emph{Lock Ray} ou du \emph{Flower Ray}. Néanmoins, la profondeur pourrait être gérée par un contrôle additionnel sur le périphérique de pointage, tel qu'une molette, par exemple.
	
	Ce qui est potentiellement plus gênant avec le \emph{Depth Ray} est le couplage des phases de pré-sélection et de désambiguïsation. Si ce couplage est bénéfique ici, on peut en douter dans le cas de cibles mobiles, où il faudrait constamment réajuster l'orientation du rayon pour continuer à \og capturer \fg{} la cible, tout en avançant ou reculant le périphérique pour placer le marqueur de profondeur au bon endroit. Nous supposons que pour des cibles petites et/ou rapides, le \emph{Depth Ray} serait très difficile à utiliser, là où un \emph{Lock/Flower Ray} pourrait fournir des performances satisfaisantes, à condition peut-être d'utiliser un cône un peu large au lieu d'un rayon cylindrique --- en réalité, ces techniques furent mises en \oe{}uvre par Grossman \emph{et al.} avec des cônes de 2\textdegree{} d'angle, même si ce n'était pas indiqué par le rendu graphique.
	
	Si le \emph{Smart Ray} fournit ici d'assez mauvais résultats, il serait intéressant de le réévaluer dans ce contexte, car d'une part, il souffrirait peut-être moins de l'occultation de la cible si elle était mobile, et d'autre part, il ne serait peut-être plus nécessaire de bouger le rayon pour lever l'ambiguïté, puisqu'en suivant la cible, son poids augmenterait continuellement, tandis que les poids des distracteurs seraient susceptibles de baisser assez rapidement --- à moins que ceux-ci ne se déplacent de façon corrélée à la cible, en étant toujours touchés par le rayon. Ainsi, les inconvénients principaux de cette technique, à savoir la distance parcourue par le périphérique et l'occultation pourraient être atténués, tandis que l'heuristique de prédiction pourrait \emph{mieux} fonctionner qu'avec des cibles statiques. Nous verrons plus loin que la technique \emph{IntenSelect}~\cite{de2005intenselect} fonctionne à peu près sur ce principe, de même que \emph{Hook}~\cite{ortega2013hook}, mais avec un curseur ponctuel. Enfin, le \emph{Smart Ray} pourrait être adapté pour utiliser, en plus du rayon projeté par le périphérique de pointage, un cône (relativement étroit) orienté selon la direction du regard de l'utilisateur. Ainsi, les objets dont les poids augmenteraient seraient ceux situés à la fois près du cône de vision de l'utilisateur et du rayon.

	\subsection{Sélection en cascade, grossière, puis fine}
	\label{sub:cascade}
	Les techniques de cette catégorie divisent la sélection en deux phases (ou plus). Premièrement, une portion de l'espace visuel est sélectionnée. Cette première phase étant grossière, elle n'a pas besoin d'être précise, et peut être très rapide. Par exemple, avec un simple périphérique de pointage, tel qu'une souris, un ratio contrôle/affichage (\emph{control/display, C/D}) très faible peut être utilisé. Le curseur (ou autre medium de sélection) peut ainsi se placer très rapidement sur la zone d'intérêt, mais n'a pas besoin d'être précisément sur la cible pour délencher la deuxième phase : la sélection (plus) fine. Dans celle-ci, l'utilisateur sélectionne la cible elle-même, par exemple à l'aide d'un ratio C/D plus élevé, ou bien affine encore l'espace de sélection, jusqu'à ce qu'une phase finale permette la sélection effective de la cible.
	 
	Du point de vue de la loi de Fitts, au cours d'une phase grossière, la cible bénéficie d'une largeur accrue (car c'est toute une zone autour de la cible qui est visée) tandis que la phase finale offre une distance réduite, puisque le curseur se trouve déjà près de la cible. En cas de zoom (ou d'augmentation du ratio C/D), elle est également (effectivement) agrandie. Quoiqu'il y ait probablement un certain \og coût cognitif \fg{} lié au basculement d'une phase à l'autre, et en tout cas un coût temporel associé à la pression d'un bouton ou à toute autre action permettant de passer à la phase suivante, les techniques de sélection en cascade peuvent améliorer significativement les performances de sélection, même pour les tâches dont l'indice de difficulté est élevé~\cite{kopper2011rapid}.
	
	La sélection en cascade revient, en substance, à préférer une série de tâches très rapides et faciles à une seule tâche nécessitant une précision élevée, prenant du temps et pouvant être source d'erreurs plus ou moins fréquentes. Observons que la sélection en cascade, du fait de la réduction du taux d'erreurs qu'elle permet, présente un intérêt particulier pour les tâches critiques, celles pour lesquelles une erreur peut avoir des conséquences graves.
	
	\subsubsection{Utilisation du regard}
	Une estimation de la direction du regard de l'utilisateur peut être utilisée soit pour sélectionner directement la cible (ce qui nécessite beaucoup de précision quand la cible est petite) ou bien une zone d'intérêt, dans la phase grossière d'une sélection en cascade. C'est généralement dans cette seconde fonction que l'on trouve cette technique, selon le principe \og le regard suggère, le toucher confirme \fg{}~\cite{stellmach2012look}. L'estimation de la direction du regard d'autrui faite par un individu est fondée sur la combinaison de la position de la tête de la personne observée, de l'orientation de sa tête, et de l'orientation de ses yeux~\cite{langton2004influence}, mais elle est fortement biaisée par l'orientation de la tête~\cite{wollaston1824apparent}.
	
	Si l'estimation de la direction du regard faite instinctivement par les êtres humains se fonde sur une méthode efficace, une méthode artificielle devrait probablement procéder de la même façon, c'est-à-dire en estimant la position et la direction de la tête d'une part, et la direction des yeux de l'autre. Murphy \emph{et al.}~\cite{murphy2009head} proposent une taxinomie et un inventaire détaillés des techniques d'estimation de la \emph{pose}\footnote{C'est-à-dire de la position \emph{et} de l'orientation.} de la tête. Ces techniques sont toutefois destinées à traiter des données vidéo brutes. Or, dans les cas qui nous intéressent, il est généralement possible d'installer des marqueurs sur la tête d'un utilisateur pour connaître plus précisément sa \emph{pose}, en s'appuyant également sur des caméras de \emph{tracking}, comme les systèmes d'Advanced Realtime Tracking.\footnotemark{} Outre sa précision, ce système est autrement plus robuste que les techniques sans marqueurs.
	
	\footnotetext{Des réseaux de caméras infrarouge permettant d'obtenir les positions précises d'un ensemble de marqueurs, donc l'orientation de l'objet marqué (éventuellement la tête d'un utilisateur).
	\url{http://www.ar-tracking.com/products/tracking-systems/arttrack-system/arttrack5}}
	
	Comme le rappellent Zhai \emph{et al.}~\cite{zhai1999manual}, l'utilisation des yeux comme entrée dans un système informatique fait l'objet de recherches depuis longtemps~\cite{levine1981eye, bolt1982eyes, ware1987evaluation, jacob1990you}. Ils remarquent également que la fovéa (la zone centrale de la macula, la zone de la rétine où la vision des détails est la plus précise), avec son angle de 1\textdegree{}, est trop grossière pour les cibles les plus petites, surtout compte tenu des mouvements aléatoires constamment effectués par les yeux~\cite{monden2005evaluation, vspakov2011comparison}. Dans une certaine mesure, ces derniers peuvent être filtrés, mais cela ne règle que partiellement le problème~\cite{zhang2008improving}.
	
	Par ailleurs, il peut être très déroutant pour un utilisateur de \og charger \fg{} un canal sensoriel, habituellement passif,\footnotemark{} d'une fonction de manipulation plus souvent dévolue à une extrémité ou un membre. Dès lors, il serait tentant de rejeter cette technique, et \emph{a fortiori} l'estimation de la \emph{pose} de la tête ne tenant pas compte des yeux, puisque c'est forcément beaucoup moins précis. Mais ce serait faire fi un peu trop rapidement des avantages du suivi des yeux, et en particulier de sa rapidité inégalée. Certes, il ne peut suffire à lui seul à sélectionner un objet d'indice de difficulté élevé, mais des études ont montré que le regard permettait de faire mieux que les périphériques de saisie traditionnels pour des tâches de sélection~\cite{stellmach2012look, ware1987evaluation, smith2000hand, bieg2010eye}.
	
	\footnotetext{Cependant quand le regard est contrôlé de façon délibérée, peut être utilisé pour communiquer, par exemple lorsqu'une personne en invite une autre, oralement, à regarder quelque chose qu'elle désigne du regard. Lever les yeux au ciel peut communiquer de l'agacement ou du dédain, etc.}
	
	\paragraph{Suivi des yeux : une tâche ardue.}

	Cependant, le suivi des yeux présente en pratique des difficultés qui peuvent être considérables, dont au moins les suivantes :
	
	\begin{itemize}
		\item Les performances peuvent dépendre de la couleur des yeux ;
		\item Le suivi des yeux ne fonctionne pas toujours bien en environnement sombre, par exemple dans un CAVE ;
		\item Les lunettes correctives peuvent nuire aux performances du système ;
		\item Les lunettes stéréoscopiques occultent partiellement les yeux pour les \emph{trackers} oculaires, et réduisent la luminosité du blanc des yeux.
	\end{itemize}

	Par conséquent, l'utilisation de suivi des yeux se montre souvent difficile à mettre en œuvre, quoique les progrès techniques puissent, dans un futur proche, pallier au moins partiellement ces difficultés. Du reste, même quand le suivi des yeux est impossible et seule la tête peut être prise en compte, les informations captées demeurent précieuses. En effet, 40~\%{} à 70~\%{} de l'orientation du regard est déterminée par la rotation de la tête, tandis que les 60~\%{} à 30~\%{} restants dépendent des mouvements oculaires~\cite{gauthier1991short}. On peut donc, le plus souvent, obtenir une bonne estimation de la direction du regard en se fondant uniquement sur l'orientation de la tête.
	
	\subsubsection{\emph{Look \&{} Touch}}
	Stellmach \emph{et al.}~\cite{stellmach2012look} ont développé et évalué plusieurs techniques fondées sur le principe de la sélection en cascade avec une phase grossière dirigée par le regard, et une phase fine s'appuyant sur un périphérique doté d'un écran tactile, tel qu'un \emph{smartphone}.
	
	\begin{enumerate}
		\item \textbf{\emph{Gaze-directed cursor} :} Ce mode très simple peut à peine être considéré comme une cascade : l'utilisateur suit sa cible des yeux, puis appuie sur un écran tactile et le relâche pour effectuer la sélection. Voir la figure~\ref{fig:lookandtouch}, à gauche.
		\item \textbf{\emph{MAGIC touch} absolue :} Technique analogue à la précédente, mais le curseur peut être déplacé en fonction de la position absolue du doigt de l'utilisateur sur son écran tactile. Voir la figure~\ref{fig:lookandtouch}, 2ème vignette.
		\item \textbf{\emph{MAGIC touch} relative :} Technique identique à la précédente, mais le curseur positionnement du curseur dépend des mouvements relatifs du doigt de l'utilisateur par rapport à son point de départ. Voir la figure~\ref{fig:lookandtouch}, 3ème vignette.
		\item \textbf{\emph{MAGIC tab} :} Technique similaire aux précédentes, mais le curseur ne bouge pas ; en revanche, l'utilisateur peut parcourir les objets comme dans un menu, en faisant glisser son doigt. Ce procédé s'inspire de la touche \emph{tabulation} d'un clavier. Voir la figure~\ref{fig:lookandtouch}, à droite.
		\item \textbf{\emph{Gaze-supported Expanded Target Selection} asservie au regard :} Le regard contrôle une lentille de zoom, inactive par défaut, mais activée en appuyant sur l'écran tactile. Une nouvelle pression permet de sélectionner la cible, tandis qu'un geste de glissement vertical permet d'ajuster le niveau de zoom. Voir la figure~\ref{fig:lookandtouch2}, à gauche et au milieu.
		\item \textbf{\emph{Gaze-supported Expanded Target Selection} semi-fixe :} Contrairement à la technique précédente, la lentille cesse de bouger une fois activée, et l'utilisateur déplace le curseur au sein de la zone de zoom à l'aide de son regard, avant d'activer la sélection avec son écran tactile. Si son regard quitte la zone de zoom, alors la lentille se déplace. Voir la figure~\ref{fig:lookandtouch2}, vignettes de gauche et de droite.
	\end{enumerate}
	
	\begin{figure}[!htbp]
		\centering
		\begin{subfigure}[t]{\textwidth}
			\centering
			\includegraphics[width=\textwidth]{figures/ch2/lookandtouch}
			\caption[\emph{Look \&{} Touch -- principe}]{Fonctionnement des quatre premiers modes de sélection en cascade de la famille \emph{Look \&{} Touch}.}
			\label{fig:lookandtouch}
		\end{subfigure}
		~
		\begin{subfigure}[t]{\textwidth}
			\centering
			\includegraphics[width=0.7\textwidth]{figures/ch2/lookandtouch2}
			\caption[\emph{Look \&{} Touch -- principe II}]{Fonctionnement des deux derniers modes de sélection en cascade de la famille \emph{Look \&{} Touch}.}
			\label{fig:lookandtouch2}
		\end{subfigure}
		\caption[\emph{Look \&{} Touch} -- principe]{\emph{Look \&{} Touch} -- principe. Crédit : \cite{stellmach2012look}.}
		\label{lookAndTouchPrinciple}
	\end{figure}
	
	\paragraph{De bons résultats, sans vainqueur clair.}
	Stellmach \emph{et al.} ont évalué les variantes de \emph{Look \&{} Touch} sus-citées dans trois blocs de tâches : T1, avec des objets disjoints sur une grille 2D ; T2, avec une ligne d'objets 2D se chevauchant ; et T3, avec des objets 2D de tailles diverses se chevauchant. Diverses tailles et distances ont également été testées. Les temps de sélection et les taux d'erreurs ont été mesurés ; ils sont rapportés sur la figure~\ref{fig:latRes}. Si le \emph{Gaze-directed cursor} montre rapidement ses limites, les autres techniques fournissent de bonnes performances, avec un léger avantage pour \emph{MAGIC tab}. Ctte tendance est confirmée par les impressions sujectives exposées sur la figure~\ref{fig:latSubj}.
	
	\paragraph{Le problème de linéarité.}
	\emph{MAGIC tab} souffre cependant d'une limitation inhérente à sa nature : le temps de sélection dans la phase fine dépend linéairement du nombre d'objets, puisque l'utilisateur les parcourt linéairement. En comparaison, la plupart des processus de sélection admettent une relation logarithmique entre le nombre d'objets et le temps de sélection~\cite{hick1952rate, hyman1953stimulus}. La robustesse de \emph{MAGIC tab} en environnement dense est donc douteuse, de même qu'avec des cibles mobiles, puisque le menu contiendrait des objets n'étant plus nécessairement dans l'espace de pré-sélection au moment où l'utilisateur les parcourt. Cette perte de contexte spatial pourrait, dans le cas de cibles visuellement très proches (ou identiques) rendre la sélection impossible.
	
	\subsubsection{\emph{Sphere-casting refined by QUAD-menu
(SQUAD)}}
	Avec \emph{Sphere-casting refined by QUAD-menu
(SQUAD)}~\cite{kopper2011rapid}, l'utilisateur commence par sélectionner un volume contenant sa cible ; puis, il affine progressivement sa sélection en choisissant le sous-ensemble de cibles contenant celle qu'il veut, via un menu à quatre options affichant tous les objets n'ayant pas encore été éliminés ; le dernier objet restant est sélectionné. Aucune des sous-tâches de SQUAD ne nécessite d'être précis. Le fonctionnement de cette technique est illustré par la figure~\ref{fig:squad}. Bien que le procédé puisse paraître pénible, il permet d'affiner la sélection jusqu'au dernier élément en $log_{4}(n)+1$ étapes, où $n$ est le nombre d'objets pré-sélectionnés par la sphère au cours de la première étape. Dans~\cite{kopper2011rapid}, SQUAD fut évaluée avec des sphères de rayons identiques --- grises pour des distracteurs, et rouges pour la cible à sélectionner (voir la figure~\ref{fig:squad2}).
	
	\paragraph{Performances.}
	Les performances de SQUAD, comparé au \emph{raycasting} et en fonction du nombre de distracteurs sont détaillées sur la figure~\ref{fig:squadDensity} : SQUAD est plus performant en environnement dense, moins en environnement peu dense, et comparable entre les deux. Les mêmes résultats sont présentés sur la figure~\ref{fig:squadSize}, mais en fonction de la taille des cibles. Les performances de SQUAD sont à peu près constantes tandis que le \emph{raycasting} est d'autant plus performant que les cibles sont grandes. De fait, SQUAD est avantageux avec de petites cibles, désavantageux quand elles sont grandes, et à peu près équivalent entre les deux. Un récapitulatif de ces résultats est présenté sur la figure~\ref{fig:squadRecap} : SQUAD gère très bien les petites cibles, mais voit ses performances chuter avec le nombre de distracteurs. Par ailleurs, le taux d'erreurs avec SQUAD était extrêmement faible (0,7~\%{}) --- un élément important en faveur de SQUAD.
	
	\begin{figure}[!htbp]
		\begin{subfigure}[t]{0.49\textwidth}
			\centering
			\includegraphics[width=0.92\textwidth]{figures/ch2/squadDensity}
			\caption{Performances en fonction de la densité de distracteurs, dont le nombre d'étapes dépend avec SQUAD.}
			\label{fig:squadDensity}
		\end{subfigure}
		~
		\begin{subfigure}[t]{0.49\textwidth}
			\centering
			\includegraphics[width=0.92\textwidth]{figures/ch2/squadSize}
			\caption{Performances de SQUAD en fonction de la taille des cibles, avec différentes densités de distracteurs.}
			\label{fig:squadSize}
		\end{subfigure}
		\caption[Performances de SQUAD]{Performances de SQUAD (brun) et du \emph{raycasting} (bleu). Crédit : \cite{kopper2011rapid}.}
		\label{fig:squadPerf}
	\end{figure}
	
	\subsubsection{\emph{Disambiguation Canvas}}
	Le fonctionnement du \emph{Disambiguation Canvas}~\cite{debarba2013disambiguation} est illustré par les figures~\ref{fig:dCanvas} et~\ref{fig:dCanvas2}. Il ne nécessite qu'un \emph{smartphone} comme périphérique de pointage pour la phase grossière, et le réutilise pour la sélection finale dans la phase fine. Dans la première, il permet une pré-sélection à l'aide d'une sphère, comme dans SQUAD~\cite{kopper2011rapid} ; dans la seconde, les objets pré-sélectionnés sont arrangés dans un rectangle de même ratio d'aspect que l'écran du téléphone, et l'utilisateur appuie avec son pouce sur la zone de l'écran du téléphone correspondant à la zone du rectangle de sélection où se trouve la cible (voir la figure~\ref{fig:dCanvas}). Pour définir un agencement optimal des objets dans la deuxième phase, dite de désambiguïsation, Debarba \emph{et al.} ont opté pour une étape de calibrage présentée sur la figure~\ref{fig:dCanvasLayout}. La taille des objets pré-sélectionnés est ajustée pour emplir l'espace de sélection dans la seconde phase, donc elle dépend du nombre d'objets pré-sélectionnés dans la première plus que de la taille initiale des objets, de même que la difficulté effective de sélection, voir la figure~\ref{fig:dCanvasDensity}.
		 
	\begin{figure}[!htbp]
		\centering
		\includegraphics[width=0.7\textwidth]{figures/ch2/dCanvas}
		\caption[\emph{Disambiguation Canvas}]{\emph{Disambiguation Canvas}. (a) : L'utilisateur pointe vers la région où sa cible est située ; cette pré-sélection se fait par \emph{volume casting}, c'est-à-dire que le périphérique de pointage contrôle un volume de sélection. (b) : Une fois la pré-sélection faite, une \og toile \fg{} (\emph{canvas}) de sélection s'ouvre, les cibles pré-sélectionnées y sont disposées et agrandies. Cette toile correspond à un \emph{mapping} absolu de l'écran tactile d'un périphérique de saisie, ce qui permet à l'utilisateur de sélectionner la cible avec son pouce. Crédit : \cite{debarba2013disambiguation}.}
		\label{fig:dCanvas}
	\end{figure}
		
	\paragraph{Performances.}
	Les performances du \emph{Disambiguation Canvas} sont présentées sur la figure~\ref{fig:dCanvasRCPerf}, comparées à celle du \emph{raycasting} classique : il ne fait mieux que le \emph{raycasting} qu'à condition que la densité soit faible ou que les cibles soient petites. Ce n'est pas surprenant puisque la sélection en cascade implique nécessairement un coût en divisant la tâche en plusieurs étapes, mais ce coût peut rester acceptable si la difficulté de la tâche est suffisamment élevée. Ses taux d'erreurs sont toujours inférieurs à ceux du \emph{raycasting}, parfois de beaucoup. C'est une caractéristique courante de la sélection en cascade, qui implique intrinsèquement un biais en faveur de la précision dans le compromis vitesse-précision inhérent à toute tâche de pointage. Enfin, l'agencement calibré des objets décrit sur la figure~\ref{fig:dCanvasLayout} n'était pas utilisé dans cette étude, puisqu'il a été inspiré par les retours des utilisateurs au cours de celle-ci --- on peut supposer qu'avec cette optimisation, les résultats obtenus seraient meilleurs. Par ailleurs, les utilisateurs rapportent une préférence marquée pour le \emph{Disambiguation Canvas} par rapport au \emph{raycasting}, surtout pour les cibles difficiles, et de même une diminution de la fatigue ressentie.
	
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=\textwidth]{figures/ch2/dCanvasRCPerf}
		\caption[\emph{Disambiguation Canvas} -- performances I]{Performances du \emph{Disambiguation Canvas}, comparées à celles du \emph{raycasting}, en fonction de la taille des cibles. Pour le premier, les résultats sont séparés en fonction de la distance angulaire entre les cibles, donc de leur densité. Plus cette densité est élevée plus la sélection est difficile car les cibles deviennent petites dans la phase de sélection fine. Les temps de sélection sont à gauche, les erreurs à droite. Crédit : \cite{debarba2013disambiguation}.}
		\label{fig:dCanvasRCPerf}
	\end{figure}
	
	Pour comparer leur technique à SQUAD, Debarba \emph{et al.} ont modifié celle-ci en ajoutant après chaque étape \og d'affichage \fg{} une animation de 200~ms repositionnant les objets dans les quadrants vidés. Quoique cette animation ait un coût, elle permet à l'utilisateur de ne pas perdre la cible qu'il souhaite sélectionner, et donc d'éviter une nouvelle phase de recherche visuelle. Pour des contextes où les objets se ressemblent (voire sont identiques) c'est un compromis qui peut être avantageux (voire indispensable). De plus, l'utilisateur peut déplacer son rayon de sélection pendant l'animation. Les résultats du \emph{Disambiguation Canvas} comparé à SQUAD sont présentés sur la figure~\ref{fig:dCanvasSPerf}, et sont en faveur de ce premier, surtout avec beaucoup d'objets. On peut toutefois s'interroger sur la solidité de ce résultat avec des objets extrêmement nombreux, puisque la convergence logarithmique de SQUAD permet en principe de gérer un nombre d'objets colossal sans dégradation catastrophique des performances, tandis que le \emph{Disambiguation Canvas} pourrait voir ses performances s'effrondrer lorsque les cibles deviennent trop petites pour être sélectionnées par une pression du pouce : les taux d'erreurs deviendraient certainement problématiques dans ce cas-là, alors qu'ils devraient rester à peu près stables pour SQUAD. Ici, SQUAD a d'ailleurs un léger avantage sur ce plan, avec 0,9~\%{} d'erreurs contre 1,8~\%{} pour le \emph{Disambiguation Canvas}, ce qui reste très bon. Les impressions subjectives des utilisateurs sont grossièrement similaires pour les deux techniques. Elles furent toutes deux évaluées avec des cibles à égale distance du périphérique de pointage, donc sans aucune occultation. Leurs performances dans des environnements denses avec beaucoup d'occultation demeurent par conséquent inconnues, et sujettes à caution.
	
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.65\textwidth]{figures/ch2/dCanvasSPerf}
		\caption[\emph{Disambiguation Canvas} -- performances II]{Temps de sélection du \emph{Disambiguation Canvas}, comparés à ceux de SQUAD, en fonction du nombre de cibles. Crédit : \cite{debarba2013disambiguation}.}
		\label{fig:dCanvasSPerf}
	\end{figure}

	
	\subsubsection{\emph{Rake cursor}}
	Le \emph{Rake cursor}~\cite{blanch2009rake} est une technique particulièrement originale, fondée sur la combinaison \emph{simultanée} de deux canaux d'interaction : une souris classique, et le regard. De fait, il ne s'agit pas d'une \og vraie \fg{} technique de sélection en cascade, puisque les phases de sélection sont simultanées --- ou du moins chevauchées --- et non successives. Le \emph{Rake cursor} se présente sous la forme d'une grille de curseurs s'étendant sur tout l'écran. Le regard de l'utilisateur est suivi afin de déterminer lequel des curseurs doit être actif, comme l'illustre la figure~\ref{fig:rakeCursor2d}.
	
	\begin{figure}[!htbp]
		\begin{subfigure}[t]{0.52\textwidth}
			\centering
			\includegraphics[width=\textwidth]{figures/ch2/rakeCursor}
			\caption{Principe de fonctionnement du \emph{Rake cursor}. Crédit : \cite{blanch2009rake}.}
			\label{fig:rakeCursor2d}
		\end{subfigure}
		~
		\begin{subfigure}[t]{0.46\textwidth}
			\centering
			\includegraphics[width=0.96\textwidth]{figures/ch2/rakeCursor1d}
			\caption{Principe de la version 1D du \emph{Rake cursor} telle qu'utilisée pour l'évaluation.}
			\label{fig:rakeCursor1d}
		\end{subfigure}
			\caption{Principe de fonctionnement du \emph{Rake cursor}. Crédit : \cite{blanch2009rake}.}
		\label{fig:rakeCursor}
	\end{figure}
	
	D'un certain point de vue, cette technique peut s'assimiler à un curseur zonal, puisque l'ensemble de curseurs couvre une grande zone de l'écran. Cependant, un curseur zonal a en principe une aire et, conceptuellement, chaque curseur n'est qu'un point, c'est-à-dire un objet géométrique d'aire nulle. Le \emph{Rake cursor} est, de fait, une technique difficile à classer, mais sa conception nous paraît inspirée par les mêmes considérations que celles qui motivent l'existence de techniques de sélection en cascade, au rafinement près que les phases de sélection se chevauchent. Par conséquent, le temps total de sélection peut être diminué. C'est l'hypothèse des auteurs, évaluée en confrontant le \emph{Rake cursor} à \emph{MAGIC}~\cite{zhai1999manual}, ainsi qu'à un curseur ponctuel standard, dans une tache de sélection à une dimension, sur le modèle de l'expérience fondatrice de Fitts. Pour l'occasion, les curseurs étaient donc remplacés par des barres verticales (voir la figure~\ref{fig:rakeCursor1d}).
	
	\paragraph{Performances.}
	Les auteurs rapportent que le \emph{Rake cursor} permet une amélioration conséquente du temps de mouvement et du taux d'erreurs, au prix cependant d'une augmentation importante du temps de réaction. Sur les tâches évaluées, cependant, dont les indices de difficulté (ID) étaient de 3, 4, 5 et 6, avec des distances de 511 et 1023 pixels, ce compromis est avantageux, comme l'illustre la figure~\ref{fig:rakeCursorPerf}, qui fait état du temps de sélection total, selon la technique et l'ID de la tâche.
	
	\begin{SCfigure}[50][htbp]
		\centering
		\includegraphics[width=0.42\textwidth]{figures/ch2/rakeCursorPerf}
		\caption[\emph{Rake cursor} -- performances]{Temps de sélection du \emph{Rake cursor}, comparés à deux d'un curseur ponctuel et de la technique \emph{MAGIC}, en fonction du nombre de l'ID de la tâche. Crédit : \cite{blanch2009rake}.}
		\label{fig:rakeCursorPerf}
	\end{SCfigure}
	
	\paragraph{Attrait et limitations.}
	Le \emph{Rake cursor} a pour intérêt essentiel de borner l'indice de difficulté du mouvement $ID_{M}$ en fonction de la distance $D_{R}$ entre deux curseurs, selon la formule de l'équation~\ref{eq:fittsRake}.
	
	\begin{equation}
		\label{eq:fittsRake}
		ID_{M} \leq \log_2\left(\frac{D_{R}}{W} + 1 \right)
	\end{equation}
	
	L'indice de difficulté de la tâche de sélection du curseur actif avec le regard, $ID_{S}$, est déterminé par la loi de Hick~\cite{hick1952rate}, et explicité par l'équation~\ref{eq:hickRake}.
	
	\begin{equation}
		\label{eq:hickRake}
		ID_{S} \leq \log_2\left(\frac{k}{D_{R}} + 1 \right)
	\end{equation}
	
	Du point de vue de la théorie de l'information, chaque ID correspond à un nombre de bits, avec l'indice de difficulté global de la tâche $ID = ID_{S} + ID_{M}$. Pour compléter la tâche, tous les bits doivent être transmis. L'originalité du \emph{Rake cursor} est de permettre la transmission de ces bits sur deux canaux en parallèle, afin de la compléter plus rapidement.
	
	Néanmoins, cette technique présente au moins deux inconvénients : d'une part, l'abondance de curseurs augmente l'encombrement visuel, dans une mesure plus ou moins gênante selon le contexte ; d'autre part, l'augmentation du temps de réaction ne peut être compensée que si le temps de mouvement est suffisamment long, c'est-à-dire si l'ID de la tâche est relativement élevé. Dans le cas contraire, le \emph{Rake cursor} pourrait nuire aux performances de sélection. Il ne paraît pas particulièrement adapté à la sélection de cibles mobiles, pour lesquelles la difficulté réside plus dans la phase d'approche de la cible que dans la phase initiale (ou balistique) permettant d'en rapprocher le curseur, et sur laquelle elle se concentre. Nous reviendrons sur ce point dans le chapitre~\ref{chap4}.
		 
	\subsubsection{Le problème de la perte du contexte}
	Les techniques de sélection en cascade pouvant prendre des formes diverses, leurs avantages et inconvénients sont également divers. Néanmoins, elles ont pour principe commun de travailler successivement à différentes échelles, ce qui peut être perturbant en environnement immersif, particulièrement lorsque l'on cherche à maintenir une correspondance entre l'espace moteur et l'espace virtuel. La question de l'influence de ces transitions forcées par le système sur le risque de \emph{cybersickness}~\cite{laviola2000discussion} (ou \og mal du simulateur \fg{}) n'est par ailleurs pas abordée par les auteurs des études citées plus haut. Néanmoins, si les gains de performances offerts par la sélection en cascade sont importants, ces désagréments pourraient être une contrepartie acceptable.
	
	Malgré les différences entre le \emph{Disambiguation Canvas} et SQUAD, leurs inconvénients majeurs sont sensiblement les mêmes : une perte de contexte en passant d'une phase à l'autre, et de grandes difficultés à reconnaître l'objet à sélectionner s'il est visuellement proche des distracteurs. Pour pallier ce problème, Debarba \emph{et al.} proposent de gérer la transition entre les deux phases avec une animation permettant de déplacer les objets de l'espace virtuel 3D d'origine vers le rectangle de sélection finale de façon progressive, afin que l'utilisateur ne perde pas sa cible des yeux et puisse la retrouver aisément. Dans une certaine mesure, le contexte spatial (local) est préservé, mais il est significativement déformé en règle générale. Cette solution, que les auteurs ont mise en \oe{}uvre mais pas encore évaluée, est illustrée par la figure~\ref{fig:dCanvasContext}.
		
	Bien que ce palliatif puisse améliorer les performances de sélection quand les objets se ressemblent, on peut douter de son efficacité quand ils sont identiques. De plus, le contexte spatial demeure dégradé en passant d'une phase à l'autre, et les cibles ne sont que statiques. Il apparaît donc difficile d'appliquer le \emph{Disambiguation Canvas} à des contextes caractérisés par des objets semblables, nombreux et mobiles, tout comme SQUAD. Cela ne revient pas à rejeter le principe de la sélection en cascade pour les applications qui nous intéressent, mais à souligner que les solutions existantes sont généralement peu adaptées à de telles tâches, et qu'une technique de sélection en cascade appropriée nécessiterait probablement d'être pensée pour les cibles mobiles dès le départ. Le \emph{Rake cursor} n'étant pas \emph{stricto sensu} une technique de sélection en cascade, il ne souffre pas précisément des mêmes inconvénients, mais demeure inadapté à la sélection de cibles mobiles, vives et imprévisibles.
	
	\subsection{Techniques de prédiction de la trajectoire du curseur}
	Une classe de techniques consiste à analyser une partie du mouvement du curseur de sélection pour tenter d'estimer son point d'arrivée, donc la cible visée par l'utilisateur, et ainsi accélérer la sélection. Les techniques \emph{Delphian Desktop} et KEP sont décrites dans les sections~\ref{sub:delphian} et~\ref{sub:kep}, respectivement.

		
	\subsubsection{\emph{Speed Profile sEparation for Endpoint Divination}}
	\emph{Speed Profile sEparation for Endpoint Divination} (SPEED)~\cite{wonner2011speed} est une heuristique de prédiction de cible. Quand l'utilisateur tente de sélectionner une cible, il déplace son curseur vers elle d'une façon que l'on peut séparer en deux phases. Au cours de la première phase, il accélère, tandis qu'il décélère pendant la seconde, comme le montre la figure~\ref{fig:speedProfile}. C'est dans cette dernière que l'utilisateur est généralement le plus précis. SPEED fonde donc sa prédiction de cible sur la phase de décélération. L'heuristique estime la distance que le curseur finira par couvrir à partir de sa vitesse, par ajustement de courbe avec celle d'une fonction quadratique. Quand le curseur a parcouru 85~\%{} de la distance totale estimée, SPEED utilise sa position et sa direction courantes, ainsi que l'estimation de la distance qu'il lui reste à parcourir pour prédire sa destination finale, donc la cible visée par l'utilisateur. Ce fonctionnement est explicité sur la figure~\ref{fig:speedExplained}.
	
	\begin{figure}[hbp]
		\begin{subfigure}[t]{0.48\textwidth}
			\centering
			\includegraphics[width=\textwidth]{figures/ch2/speedProfile}
			\caption{Profil de vitesse au cours d'un mouvement de pointage. À partir du seuil $V_{0}$, fixé empiriquement, SPEED considère que le mouvement commence. La vitesse croît, puis redescend jusqu'à s'annuler, dans une courbe asymétrique.}
			\label{fig:speedProfile}
		\end{subfigure}
		~
		\begin{subfigure}[t]{0.50\textwidth}
			\centering
			\includegraphics[width=0.8\textwidth]{figures/ch2/speedExplained}
			\caption{Vitesse $v$ du curseur en fonction de la distance $d$ parcourue. Lorsque le pic global de vitesse $d_picg$ est atteint, la phase de décélération commence, et les points $(d_{i}, v_{i})$ mesurés au cours de celle-ci sont utilisés pour y ajuster une fonction quadratique.}
			\label{fig:speedExplained}
		\end{subfigure}
		\caption[SPEED -- fonctionnement]{SPEED -- fonctionnement. Crédit : \cite{wonner2011speed}.}
		\label{fig:speedCursor}
	\end{figure}
	
	\paragraph{Performances.}
	SPEED fournit de bien meilleurs résultats de prédiction que les précédentes approches de ce type, qui ne faisaient pas de distinction entre les phases d'accélération et de décélération, comme l'illustre le tableau~\ref{tab:speedingPastKep}, qui présente les résultats de SPEED face à ceux de KEP, précédemment la meilleure technique de prédiction de point d'arrivée. Les résultats de SPEED sont corrects même avec un indice de difficulté très élevé (contre 26,2~\%{} pour SPEED et 0~\%{} pour KEP).

	
	\begin{table}
	\centering
	\begin{tabular}{r | c c c}
				& \multicolumn{3}{c}{Distance}	\\
		Taille	& 512					& 1024					& 1536					\\ \hline
		16		& 32,1 / \emph{5,0}		& 30,8 / \emph{2,0}		& 26,2 / \emph{0,0}		\bigstrut[t] \\
		32		& 43,0 / \emph{17,0}	& 38,1 / \emph{3,0}		& 35,1 / \emph{2,0}		\\
		64		& 50,5 / \emph{35,0}	& 45,4 / \emph{16,0}	& 46,5 / \emph{10,0}	\\
		128		& 74,3 / \emph{76,0}	& 60,9 / \emph{33,0}	& 47,9 / \emph{22,0}	\\
	\end{tabular}
	\caption[SPEED -- performances comparées à celles de KEP]{Fiabilité des prédictions de l'algorithme SPEED en fonction de la taille des cibles (16 à 128 pixels), et de la distance du mouvement à accomplir (512 à 1536 pixels). Pourcentages de prédictions correctes, avec les taux produits par SPEED en police romaine et ceux de KEP en italique. Données tirées de~\cite{wonner2011speed}.}
	\label{tab:speedingPastKep}
	\end{table}
		
	\subsubsection{L'hypothèse de rectitude et les cibles mobiles}
	Les techniques de prédiction de la trajectoire du curseur ont un point faible commun : leur hypothèse de base selon laquelle la trajectoire du curseur est rectiligne. Quoique raisonnable pour les cibles statiques, elle ne tient pas quand les cibles sont mobiles, surtout si elles sont rapides et leurs mouvements sont imprévisibles. Elle peut être une approximation acceptable pour des mouvements relativement petits et/ou vers des cibles relativement lentes, ou dont les mouvements sont suffisamment prévisibles pour que l'utilisateur puisse anticiper leur position dans l'avenir proche, mais dans les cas qui nous intéressent particulièrement et qui sont détaillés dans le chapitre~\ref{chap1}, ce n'est pas souvent le cas. Nous ne pouvons donc retenir ces techniques pour ces applications. Toutefois, même pour une sélection de cible mobile, une phase balistique peut exister, et l'on peut supposer qu'une telle technique puisse l'accélérer. Mais plus les cibles sont rapides et imprévisibles, plus la phase de correction domine temporellement la phase balistique.

\section{Techniques pour la sélection de cibles mobiles}
	Étudions à présent les techniques conçues pour la sélection de cibles mobiles, sachant que malgré ce focus, elles permettent également de sélectionner des cibles statiques, en améliorant ou non les performances de sélection.
	
	\subsection{Techniques de manipulation du temps}
	\label{sub:timeLord}
	Certaines techniques cherchent à faciliter la sélection de cibles mobiles par une forme de manipulation du temps. Celui-ci peut être ralenti, arrêté momentanément, ou altéré d'une autre manière. Nous allons ici présenter des techniques de ce type.	La technique \emph{Hold} est décrite dans la section~\ref{sub:hold}.
	
	\subsubsection{\emph{Target/Bubble Ghost}}
	\emph{Target Ghost}~\cite{hasan2011comet} est une technique qui repose sur un déclenchement délibéré. Quand elle est déclenchée par l'utilisateur, \emph{Target Ghost} duplique toutes les cibles potentielles. Une des copies devient statique et reste opaque, tandis que l'autre demeure mobile mais est rendue semi-transparente, comme l'illustre la figure~\ref{fig:targetGhost}.
	
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.5\textwidth]{figures/ch2/targetGhost}
		\caption[La technique \emph{Target Ghost}]{\emph{Target Ghost} avec un curseur basique. Quand elle est \og \emph{ghostée} \fg{} la cible originale est désaturée, mais poursuit sa trajectoire. Un proxy plus vif de l'objet demeure figé et peut, seul, être sélectionné. Crédit : \cite{hasan2011comet}.}
		\label{fig:targetGhost}
	\end{figure}
	
	L'utilisateur peut ensuite sélectionner la version statique et opaque de la cible, qui sert de proxy pour sa jumelle mobile. Cela permet de ramener une tâche de sélection de cible mobile à une simple sélection de cible statique. Naturellement, cela facilite considérablement les choses, ce qui permet d'améliorer significativement les temps de sélection et, dans une plus grande mesure encore, les taux d'erreurs, comme le montrent les graphiques des figures~\ref{fig:cometGhostTimes}, \ref{fig:cometGhostErrors} et~\ref{fig:cometGhostPredictability}. De plus, cette technique n'affectant que les cibles, elle peut être combinée à une technique de curseur, ce qui fut d'ailleurs fait avec le \emph{Bubble Cursor}, pour une combinaison baptisée \emph{Bubble Ghost}~\cite{hasan2011comet}.

	\begin{SCfigure}[50][htbp]
		\centering
		\includegraphics[width=0.4\textwidth]{figures/ch2/cometGhostPredictability}
		\caption[\emph{Comet/Ghost}, prévisibilité et résultats]{Temps de complétion de la tâche, (a) : en fonction des types de curseur, avec ou sans \emph{Ghost}, (b) : en fonction de la prévisibilité du chemin pris par la cible. La technique \emph{Comet} est décrite dans la section suivante. Crédit : \cite{hasan2011comet}.}
		\label{fig:cometGhostPredictability}
	\end{SCfigure}
	
	
	
	

	\begin{figure}[htbp]
		\begin{subfigure}[t]{0.49\textwidth}
			\centering
			\includegraphics[width=\textwidth]{figures/ch2/cometGhostTimes}
			\caption{Temps de de sélection de chaque technique avec et sans \emph{Ghost}. Le \emph{ghosting} est bénéfique sur un curseur basique, mais néfaste dans les autres cas.}
			\label{fig:cometGhostTimes}
		\end{subfigure}
		~
		\begin{subfigure}[t]{0.49\textwidth}
			\centering
			\includegraphics[width=0.8\textwidth]{figures/ch2/cometGhostErrors}
			\caption{Taux d'erreurs pour la tâche de sélection, avec et sans \emph{Ghost}. Le \emph{ghosting} est très bénéfique, mais augmente le temps de sélection (sauf avec un curseur basique).}
			\label{fig:cometGhostErrors}
		\end{subfigure}
		\caption[\emph{Comet Ghost} -- temps de sélection et taux d'erreurs]{\emph{Comet Ghost} -- performances. Crédit : \cite{hasan2011comet}.}
		\label{fig:cometGhostTimeErrors}
	\end{figure}
	
	\paragraph{\emph{Ghosting} et encombrement visuel.}
	Là encore, l'encombrement visuel est un problème, puisque le nombre de cibles affichées double avec \emph{ghosting}, même si la moitié d'entre elles sont semi-transparentes. Cela peut par ailleurs aggraver le problème d'occultation : en effet, si une cible mobile passe derrière un objet statique ou une autre cible potentielle, déclencher \emph{Target/Bubble Ghost} à cet instant a pour effet de prolonger indéfiniment l'occultation de cette cible. Ce problème est d'autant plus gênant que la densité de cibles potentielles est élevée. L'utilisation d'un proxy peut aussi être gênante dans un contexte immersif avec un périphérique de saisie permettant une correspondance à l'échelle 1 entre l'espace moteur et l'espace virtuel, en particulier si la sélection a pour but de permettre une manipulation de l'objet saisi. C'est notamment le cas pour les simulations de dynamique moléculaire, qui impliquent d'envoyer des forces au système simulé, avec un retour (pseudo-)haptique pour l'utilisateur.
		
	\subsubsection{Perte du contexte dynamique}
	Les techniques de manipulation du temps impliquent d'arrêter (ou d'altérer) les mouvements des cibles, ce qui est inacceptable dans bon nombre d'applications, comme la plupart des jeux vidéo, par exemple. Pour les simulations moléculaires ou encore le contrôle de divers espaces, les retransmissions d'événements sportifs, etc., cela implique une déconnexion avec le réel, souvent inacceptable. Les simulations interactives collaboratives (impliquant plusieurs utilisateurs éventuellement distants, et utilisant des dispositifs différents mais synchronisés) posent problème : \emph{Hold} inmpliquerait soit l'imposition par un utilisateur à tous les autres d'un arrêt de la simulation, soit la désynchronisation des différentes simulations. Certains jeux vidéo sont également dans ce cas de figure, surtout avec un très grand nombre d'utilisateurs simultanés. Certes, \emph{Target/Bubble Ghost} propose un palliatif (ses fantômes), mais ce n'est que partiellement efficace, et au prix d'un encombrement visuel presque doublé.
	
	\subsection{Techniques fondées sur l'augmentation des objets}
	\label{sub:techAug}
	Certaines techniques se fondent sur la loi de Fitts et son énoncé de l'importance de la largeur de la cible pour faciliter la sélection en augmentant les cibles, de façon à accroître leur taille effective. Attardons-nous sur deux d'entre elles.

	\subsubsection{\emph{AttachedShock}}
	\emph{AttachedShock}~\cite{you2012attachedshock, you2014attachedshock} fut développée pour répondre à un besoin spécifique à la réalité augmentée : la sélection d'objets \og fuyants \fg{} : lorsqu'un utilisateur se déplace dans une direction, les objets à côté desquels il passent quittent son champ de vision rapidement, et de plus en plus vite à mesure que qu'ils s'approchent des bords du champ de vision, comme l'illustre la figure~\ref{fig:as2dspeed}.

	\begin{SCfigure}[50][!htbp]
		\includegraphics[width=0.28\textwidth]{figures/ch2/as2dspeed}
		\caption[\emph{AttachedShock}, profil de vitesse]{Vue d'un utilisateur dans une voiture, fixant la route. Des objets (les sphères vertes) attirent son attention. Ils sont fixés au sol, mais leur vitesse relative (par rapport au référentiel de la voiture) est celle de la voiture dans le référentiel terrestre. Une fois projetée sur un écran 2D, elle varie considérablement en fonction de la distance de l'objet au centre de l'écran. On peut parler de \emph{vitesse apparente}. Crédit : \cite{you2012attachedshock}.}
		\label{fig:as2dspeed}	
	\end{SCfigure}
	
	Pour faciliter la sélection de telles cibles sans trop augmenter l'encombrement visuel de la scène, les auteurs d'\emph{AttachedShock} ont d'ajouté aux objets apparemment en mouvement une onde de choc, comme sur la figure~\ref{fig:asas}. Cette onde augmente l'objet et en facilite la sélection, qui se fait en \og traversant \fg{} l'onde de choc d'un objet, ce qui permet aux utilisateurs d'effectuer un mouvement balistique sans avoir à ralentir comme ils le devraient avec une cible non augmentée.
	
	\begin{figure}[htbp]
		\centering
		\begin{subfigure}[t]{0.48\textwidth}
			\centering
			\includegraphics[width=\textwidth]{figures/ch2/asas}
			\caption{Gauche : onde de choc d'un avion supersonique. Droite : cible mobile et son \og \emph{AttachedShock} \fg{}.}
			\label{fig:asas}
		\end{subfigure}
		~
		\begin{subfigure}[t]{0.48\textwidth}
			\centering
			\includegraphics[width=0.8\textwidth]{figures/ch2/asRes}
			\caption{Performances d'\emph{AttachedShock}. Taux d'erreurs est en abscisse ; temps de sélection en ordonnée.}
			\label{fig:asRes}
		\end{subfigure}
		\caption{\emph{AttachedShock}. Source :~\cite{you2012attachedshock}.}
		\label{fig:asMain}
	\end{figure}
	
	Cette technique limite l'encombrement visuel en optant pour une augmentation visuelle pouvant être perçue comme \og naturelle \fg{}. Les auteurs ont comparé \emph{AttachedShock} à d'autres techniques de référence, dont un curseur ponctuel mais aussi un curseur zonal, ainsi que \emph{Comet}, présentée plus bas. La technique \emph{AttachedShock} s'est montrée meilleure que toutes les autres dans cette évaluation, quoique de peu pour le temps de sélection. Les résultats détaillés sont sur la figure~\ref{fig:asRes}. Dans les conditions du protocole de test mis en place par les auteurs, \emph{AttachedShock} permet une sélection rapide et fiable par rapport aux techniques existantes, avec un encombrement visuel contenu. Toutefois, la densité de cibles testée par les auteurs est très faible (voir la figure~\ref{fig:asDensity}). La technique n'ayant pas été évaluée avec une grande densité de cibles, il est impossible d'affirmer qu'elle fonctionnerait bien dans de telles conditions, mais l'on peut en douter compte tenu du fait qu'elle repose sur la possibilité qu'a l'utilisateur de se \og contenter \fg{} de mouvements balistiques sans mouvements correctifs, ce qui serait bien difficile avec les obstacles que de nombreux distracteurs constitueraient.
	
	\begin{figure}[htbp]
		\centering
		\includegraphics[width=0.6\textwidth]{figures/ch2/asDensity}
		\caption[\emph{AttachedShock}, densité de cibles]{Dispositif d'évaluation d'\emph{AttachedShock}. Gauche : expérience menée sur un segment de route rectiligne ; droite : sur un segment courbe. Sphère rouge : cible à sélectionner ;  vertes : distracteurs, peu nombreux. Crédit: \cite{you2012attachedshock}.}
		\label{fig:asDensity}
	\end{figure}
	
	En outre, dans cette évaluation les cibles sont fixées au sol, et donc ne se déplacent à l'écran qu'à l'horizontale. De fait, leurs ondes de choc se présentent toujours dans la même orientation. Or, dans bien des cas, les cibles peuvent changer de direction en cours de route, ce qui soumettrait ces ondes de choc à des rotations. Dans ces condtions, déclencher un mouvement balistique pour traverser l'onde de choc sans mouvements correctifs serait plus difficile. Ainsi, si \emph{AttachedShock} présente un intérêt certain dans le contexte évalué ici, son efficacité en environnement dense et/ou avec des cibles changeant souvent de direction, \emph{a fortiori} de manière imprévisible, demeure à démontrer, et s'annonce moindre.
	
	\subsubsection{\emph{(Bubble) Comet}}
	Avec \emph{Comet}~\cite{hasan2011comet}, chaque cible potentielle laisse derrière elle une traînée (ou queue) qui peut être sélectionnée à la place de la cible elle-même, comme le montre la figure~\ref{fig:comet}.

	\begin{SCfigure}[50][!htbp]
		\centering
		\includegraphics[width=0.46\textwidth]{figures/ch2/comet}
		\caption[La technique \emph{Comet}]{(a) La cible et sa queue de comète. (b) La queue est mise en surbrillance lorsque le curseur passe dessus. (c) Les queues peuvent être recouvertes par les cibles ajdacentes. Crédit : \cite{hasan2011comet}.}
		\label{fig:comet}
	\end{SCfigure}
	
	Cela revient à augmenter la taille effective des cibles. Attendu que cela s'applique aux cibles et pas aux curseurs, \emph{Comet} peut être combinée à une technique de curseur, par exemple le \emph{Bubble Cursor} ou \emph{DynaSpot}. Hasan \emph{et al.} ont montré que cette technique permet de significativement améliorer les temps de sélection et les taux d'erreurs pour les cibles mobiles en 2D~\cite{hasan2011comet}, comme le montrent les résultats compilés sur les figures~\ref{fig:cometGhostTimes}, \ref{fig:cometGhostErrors} et~\ref{fig:cometGhostPredictability}.

	\subsubsection{Limites des techniques fondées sur l'augmentation}
	Les techniques fondées sur l'augmentation ont un inconvénient commun : l'encombrement visuel accru, et les techniques détaillées ici ne font pas exception. De plus, elles modifient la représentation visuelle des cibles, et en particulier de leur forme. Pour certaines applications, par exemple les simulations moléculaires (dans lequelles la perception des formes des molécules est absolument critique) ce point est particulièrement gênant, tandis que l'encombrement visuel est d'autant plus problématique que l'environnement de départ est dense et présente un haut degré d'occultation.

	\subsection{Techniques de prédiction intentionnelle}
	Les techniques de prédiction intentionnelle cherchent à prédire l'intention de l'utilisateur à partir de ses actions ; en \og devinant \fg{} quelle cible il souhaite choisir, elles visent à lui proposer de le faire de façon très accélérée. Nous allons ici examiner deux techniques de ce type, mais précisons que le \emph{Smart Ray}, décrit dans la section~\ref{sec:raycasting}, pourrait être considéré comme une technique de prédiction intentionnelle.
	
	\subsubsection{\emph{IntenSelect}}
	\label{sub:intenSelect}
	De Haan \emph{et al.}~\cite{de2005intenselect} observent que le \emph{raycasting} fonctionne mal pour sélectionner des objets petits, fins, ou distants, occultés ou dans un milieu très dense, ou caractérisés par un comportement dynamique complexe. C'est pour cette raison qu'ils ont développé une nouvelle méthode d'interaction baptisée \emph{IntenSelect}, visant à faciliter la sélection de cibles. Ils identifient notamment les simulations de dynamique moléculaire comme une application particulièrement exigeante, ainsi que nous le soulignions dans le premier chapitre de ce manuscrit. Cette observation est illustrée par la figure~\ref{fig:intensMD}. De Haan \emph{et al.} notent par ailleurs que le mouvement des cibles ne fait qu'exacerber les difficultés rencontrées avec les cibles distantes et/ou de petite taille.
	
	\paragraph{Algorithme.}
	L'algorithme \emph{IntenSelect} peut être décrit simplement en quatre étapes :
	
	\begin{description}
		\item[1. Test dans le volume de sélection :] Déterminer quels objets sont dans le cône de sélection ;
		\item[2. Contributions aux scores :] Chaque objet dans le volume de sélection se voit attribué un score, déterminé à partir d'une métrique spécifique ;
		\item[3. Accumulation des scores :] Les contributions aux scores des objets s'accumulent avec le temps ;
		\item[4. Retour (\emph{feedback}) :] L'objet de score maximal, donc de premier rang, est mis en surbrillance et indiqué par un rayon qui se \og tord \fg{} vers lui.
	\end{description}
	
	\paragraph{Test d'appartenance au volume de sélection.}
	Le volume de sélection est un simple cône, et pour chaque point donné, il suffit de vérifier s'il est dans le cône pour déterminer s'il est dans le volume de sélection, et donc s'il doit être pris en compte pour l'étape 2 de l'algorithme. Le détail du test d'appartenance est fourni par la figure~\ref{fig:intensCone}.
	
	\paragraph{Métrique.}
	La métrique utilisée dans l'étape 2 est illustrée par la figure~\ref{fig:intensMetric}.
	
	\begin{figure}[!htbp]
		\begin{subfigure}[t]{0.49\textwidth}
			\centering
			\includegraphics[width=\textwidth]{figures/ch2/intensMD}
			\caption{Schéma illustrant la sélection d'un atome dans une simulation de dynamique moléculaire. L'environnement très dense rend la tâche particulièrement difficile.}
			\label{fig:intensMD}
		\end{subfigure}
		~
		\begin{subfigure}[t]{0.49\textwidth}
			\centering
			\includegraphics[width=\textwidth]{figures/ch2/intensMetric}
			\caption{Métrique de \emph{scoring} : cône de sélection vu de côté, où sa surface est tracée en pointillés rouges et le rayon en noir, avec un point P inclus dedans. La valeur de la métrique est indiquée par la couleur : 1 en blanc, 0 en noir.}
			\label{fig:intensMetric}
		\end{subfigure}
		\caption[\emph{IntenSelect} et métrique]{\emph{IntenSelect} et métrique. Crédit : \cite{de2005intenselect}.}
		\label{fig:plop}
	\end{figure}
	
	\paragraph{Accumulation des scores.}
	Les contributions au score d'une cible donnée s'accumulent avec le temps dans un score global, qui décroît progressivement en l'absence de contributions suffisantes. L'équation~\ref{eq:intensContrib} décrit la contribution au score d'une cible donnée à l'instant $t$, et l'équation~\ref{eq:intensTotal} définit le score total d'une cible. Pour les grandeurs de l'équation~\ref{eq:intensContrib}, se référer à la figure~\ref{fig:intensCone} et à sa légende ; $k$ est une constante réelle. Pour l'équation~\ref{eq:intensTotal}, $s_{total}(t)$ est le score total à l'instant $t$, $c_{s}$ est le taux de diminution naturelle du score, et $c_{g}$ est son taux de croissance ; ces deux constantes réelles sont déterminées empiriquement. De Haan \emph{et al.} précisent qu'elles représentent un compromis entre \emph{snappiness} et \emph{stickiness}, c'est-à-dire qu'elles déterminent l'inertie de la sélection.
	
	\begin{align}
		\label{eq:intensContrib}
		s_{contrib}(t) &= 1 - \frac{\arctan \left(\frac{d_{perp}(t)}{\left(d_{proj}(t)\right)^{k}}\right)}{\beta_{cone}} \\
		\label{eq:intensTotal}
		s_{total}(t) &= s_{total}(t-1)c_{s} + s_{contrib}(t)c_{g}
	\end{align}
	
	Un exemple synthétique d'accumulation de score par une cible d'abord hors du volume de sélection, puis dedans, puis à nouveau dehors est représenté sur la figure~\ref{fig:intensAccumul}.


	
	\paragraph{Retour (\emph{feedback}).}
	À tout instant, l'objet dont le score accumulé est maximal est considéré comme la cible choisie ou active. Le rayon est une courbe de Bézier atteignant la cible visée (ou du moins estimée). Ce mécanisme est illustré sur la figure~\ref{fig:intenSnap}. Tant que la cible prédite reste la même, le rayon s'adapte pour se plier vers elle ; si elle change, le rayon saute immédiatement vers la nouvelle. L'utilisation d'une heuristique avec une certaine \og inertie \fg{} rend la technique plus robuste pour les sélections difficiles, particulièrement avec des cibles mouvantes (voir la figure~\ref{fig:intenSnap2}).
	
	\paragraph{Flexibilité.}
	De Haan \emph{et al.} font remarquer que leur technique confère une certaine flexibilité, puisque les fonctions de calcul et accumulation du score peuvent être modifiées, non seulement pour chaque application, mais encore pour chaque objet. Ainsi, un objet ayant une plus forte probabilité d'intéresser l'utilisateur pourrait avoir un score croissant plus rapidement ; un objet ayant une sous-partie d'intérêt particulier (comme une porte et sa poignée) pourrait rediriger le score du tout vers la partie. Les possibilités sont extrêmement nombreuses et laissées à la libre appréciation des concepteurs d'applications. Reconnaissons simplement l'avantage (potentiellement considérable) de fonctions de \emph{scoring} facilement paramétrables.
	
	\paragraph{Performances.}
	Les performances d'\emph{IntenSelect} sont bonnes, particulièrement avec des cibles mobiles --- c'est du moins ce qu'indique l'étude menée par de Haan \emph{et al.}~\cite{de2005intenselect}, qui mettent tout de même le lecteur en garde en précisant qu'ils n'avaient que 8 sujets. Leurs résultats sont présentés sur la figure~\ref{fig:intensPerf}. Bien qu'\emph{IntenSelect} ne fasse pas mieux que la sélection par cône avec des cibles statiques, il est plus efficace avec des cibles mobiles. Les sujets expérimentés de cette étude empirique rapportent parfois qu'avec des cibles statiques, \emph{IntenSelect} était trop \og collant \fg{}. De fait, ils étaient forcés d'attendre un peu avant que le rayon s'attache à la cible qu'ils visaient réellement. Les autres sujets ne rapportent pas de différence, mais furent en réalité \emph{plus} rapides avec \emph{IntenSelect}.
	
	\begin{SCfigure}[50][!htbp]
		\centering
		\includegraphics[width=0.5\textwidth]{figures/ch2/intensPerf}
		\caption[\emph{IntenSelect} -- performances]{Performances de la technique \emph{IntenSelect} en sélection de cibles statiques (à gauche) et mobiles (à droite), comparée au \emph{raycasting} et à la sélection par cône. Les résultats ne se démarquent pas de ceux de la sélection par cône avec des cibles statiques mais c'est le cas quand elles bougent. Les boîtes représentent les données entre le premier et le dernier quartile, avec la valeur médiane indiquée en rouge. Crédit : \cite{de2005intenselect}.}
		\label{fig:intensPerf}
	\end{SCfigure}
	
	Nous pouvons émettre l'hypothèse que cette technique n'est utile que lorsque la tâche est difficile, et que la difficulté effective varie d'un utilisateur à l'autre. Peut-être serait-il opportun de réduire l'inertie de la fonction de \emph{scoring} pour les tâches les plus faciles, ce qui inclut les tâches de difficulté modérée effectuées par des utilisateurs expérimentés. Observons que certains utilisateurs très expérimentés ont réussi à obtenir de bons résultats avec le \emph{raycasting} sur des cibles mobiles\ldots{} en tirant parti de la périodicité de leurs mouvements pour les intercepter. Il nous semble qu'ils ont ici exploité une faille du protocole expérimental. Dans un contexte plus réaliste --- peu des applications que nous avons identifiées dans le premier chapitre présentent des cibles aux mouvements périodiques --- le \emph{raycasting}, et sans doute la sélection par cône, auraient probablement obtenu des résultats moins bons encore. Naturellement, les performances relatives d'\emph{IntenSelect} ne s'en trouveraient qu'améliorées.
	
	\paragraph{Lacunes avec les cibles statiques.}
	Le premier inconvénient d'\emph{IntenSelect} est évident : il s'est montré moins performant que la sélection par cône avec des cibles statiques\ldots{} mais nous avons proposé des solutions à ces problèmes ci-dessus. Sans doute le calibrage optimal et adaptatif des paramètres de la technique nécessiterait-il une étude entière à lui seul, mais le potentiel nous paraît grand.
	
	L'étude menée par de Haan \emph{et al.} est, de leur propre aveu, informelle, et dans la condition dite dynamique, ils ne se sont intéressés qu'à des cibles de taille relativement grande. Par ailleurs, la nature du mouvement de ces cibles n'est pas précisée, même si les auteurs révèlent qu'il était périodique, ce qui ne nous semble pas souhaitable pour une étude ce type. La question de la robustesse d'\emph{IntenSelect} pour des tâches particulièrement difficiles avec des cibles plus petites, beaucoup plus nombreuses, avec des mouvements rapides et imprévisibles demeure donc ouverte. Néanmoins, qu'\emph{IntenSelect} nous paraît mieux équipée que bien d'autres techniques pour gérer ces considérables difficultés.
		
	\subsubsection{Hook}
	\label{sub:hook}
	\emph{Hook}~\cite{ortega2013hook} est une heuristique de prédiction fondée sur une évaluation continue de la distance entre le curseur et les cibles potentielles. Celles-ci sont triées par ordre de proximité, et les $NCT$ (\emph{Number of Closest Targets}) objets les plus proches du curseur voient leur score augmenter à chaque boucle de l'heuristique, et augmenter d'autant plus fortement qu'ils sont proches du curseur. Tous les autres objets voient leur score diminuer, et ce d'autant plus fortement qu'ils sont éloignés du curseur. La cible potentielle dont le score est le plus élevé est considérée comme celle que l'utilisateur cherche probablement à sélectionner. La sélection peut donc se faire par simple pression d'un bouton, sans contrainte particulière sur la position du curseur au moment où elle est déclenchée.

	L'hypothèse de base sur laquelle repose \emph{Hook} est que puisque l'utilisateur, lorsqu'il essaie de sélectionner une cible mobile, \og suit \fg{} ses mouvements avec son curseur~\cite{hasan2011comet}, la trajectoire de celui-ci sera fortement corrélée à celle de la cible, et permettra donc de l'identifier. \emph{Hook} est une technique pensée pour les cibles mobiles, mais elle est également bien adaptée aux environnements denses, car elle ne repose pas sur un agrandissement effectif des objets (comme le \emph{Bubble Cursor}) ou sur l'hypothèse que la cible n'est pas occultée, comme la plupart des techniques de \emph{raycasting}. Elle ne modifie pas l'apparence des cibles, et n'interrompt pas l'animation ou la simulation en cours. Si un retour graphique indique la cible prédite en la mettant en surbrillance dans une sphère semi-transparente et en affichant un cône semi-transparent du curseur vers la cible, l'encombrement visuel qui en résulte est minimal (voir la figure~\ref{fig:hookPic}).
	
	\paragraph{Calcul du score.}
	Comme pour toutes les heuristiques de ce type, le calcul du score doit tenir compte de deux impératifs contradictoires, afin d'aboutir à un bon compromis : la prédiction de la cible présumée doit être suffisamment stable pour ne pas perturber l'utilisateur par d'incessants changements, mais doit pouvoir changer suffisamment vite (lorsqu'elle est fausse ou quand l'utilisateur change de cible) pour permettre une sélection rapide. La solution retenue par Ortega~\cite{ortega2013hook} se résume en deux formules simples. La première décrit l'évolution dans le temps des objets les plus proches du curseur :
	
	$$ Score_{cible_{i}}(t) = Score_{cible_{i}}(t-1) + (NCT - i) \times \Delta{}t $$
	
	La seconde définit celle des objets éloignés du curseur :
	
	$$ Score_{cible_{i}}(t) = Score_{cible_{i}}(t-1) - \frac{NCT}{2} \times \Delta{}t $$
	
	Un score ne peut jamais être négatif, il est donc ramené à zéro le cas échéant. $Score_{cible_{i}}(t)$ est le score de la cible $i$ à l'instant $t$, et $\Delta{}t$ est le temps écoulé depuis la précédente itération. À tout instant, l'objet de score maximal peut être sélectionné en activant un seul contrôle d'un périphérique de saisie. Cette technique spécifiquement conçue pour les cibles mobiles fonctionne également pour les cibles statiques, puisque le calcul du score ne nécessite pas que les objets bougent. De même, \emph{Hook} fonctionne avec un périphérique de saisie à deux degrés de liberté, en effectuant les calculs de score dans un plan sur lequel l'espace 3D est projeté.
	
	\paragraph{Performances.}
	Ortega a évalué sa technique en 2D et en 3D, avec 100 objets mobiles, à 5 vitesses différentes~\cite{ortega2013hook}. À chaque étape de l'animation des objets, le vecteur direction de chaque objet subit une rotation comprise dans un cône de 10\textdegree. Le but est de générer un mouvement relativement imprévisible, mais non brownien. Ce processus est illustré par la figure~\ref{fig:hookDir}. L'évaluation menée par Ortega montre que \emph{Hook} est non seulement plus rapide que le \emph{Bubble Cursor} en 2D comme en 3D, mais permet en plus des taux d'erreurs plus faibles. Lorsque les cibles sont rapides, le taux d'erreurs peut être moindre d'un facteur supérieur à 4. Ces résultats valent en 2D (voir la figure~\ref{fig:hookRes2d}) comme en 3D (voir la figure~\ref{fig:hookRes3d}). La sélection non assistée est si inadéquate à la tâche que les sujets ne purent sélectionner les cibles en 3D à partir de la vitesse 3.

	\begin{figure}[htbp]
		%\centering
		\begin{subfigure}{\textwidth}
			\centering
			\includegraphics[width=0.8\textwidth]{figures/ch2/hookRes2d}
			\caption[\emph{Hook} -- performances en 2D]{2D : temps de sélection (gauche) et taux d'erreurs (droite) en fonction de la vitesse.}
			\label{fig:hookRes2d}
		\end{subfigure}
		~
		\begin{subfigure}{\textwidth}
			\centering
			\includegraphics[width=0.8\textwidth]{figures/ch2/hookRes3d}
			\caption[\emph{Hook} -- performances en 2D]{3D : temps de sélection (gauche) et taux d'erreurs (droite) en fonction de la vitesse.}
			\label{fig:hookRes3d}
		\end{subfigure}
		\caption[\emph{Hook} -- Performances]{Performances de la technique \emph{Hook}. Crédit : \cite{ortega2013hook}.}
	\end{figure}
	
	\paragraph{Environnements denses à objets liés.}
	Les qualités et avantages de \emph{Hook} sont nombreux, mais plusieurs interrogations demeurent. Premièrement, les performances relatives de cette technique seraient-elles aussi bonnes avec d'autres types de mouvements, ou avec des objets beaucoup plus nombreux, avec plus d'occultation encore ? Surtout, nous nous interrogeons sur les performances de \emph{Hook} avec de denses groupes d'objets aux mouvements corrélés, par exemple un banc de poissons, un groupe d'oiseaux en formation, ou une escadrille d'avions. Dans ces situations, \emph{Hook} pourrait avoir du mal à distinguer la cible visée des objets environnants, puisque leurs positions seraient très proche et leurs mouvements très similaires. Néanmoins, cette technique présente suffisamment de qualités dans le contexte de la sélection de cibles mobiles en environnement dense pour retenir notre attention, et il nous apparaît qu'elle forme le meilleur point de départ pour la conception d'une technique optimale pour cette classe de tâches.
	
	\subsubsection{Erreurs de prédiction et frustration}
	Toutefois, il convient de ne pas négliger les faiblesses des approches de prédiction intentionnelle, au premier rang desquelles figurent les erreurs de prédiction, et la frustration qu'elles peuvent causer chez les utilisateurs, qui peuvent rapidement être très agacés de ne pouvoir obtenir du système le comportement qu'ils attendent. Les heuristiques utilisées doivent donc être soigneusement calibrées, d'une part pour minimiser les erreurs de prédiction, et d'autre part pour éviter de (trop) nuire aux performances de sélection, le cas échéant. Ce point peut être primordial pour les applications nécessitant un temps de sélection borné, ou imposant des contraintes sur les taux d'erreurs.
	
\section{Discussion de la taxinomie proposée}
    Comme nous venons de le voir, les techniques d'aide à la sélection sont de natures diverses. Elles consistent souvent, selon les principes de la loi de Fitts, à faciliter la sélection d'une cible en augmentant la largeur effective de la cible, ou en réduisant sa distance effective au curseur. Nous présentons ici nos réflexions sur la taxinomie des techniques de sélection introduite par la figure~\ref{fig:selTaxi}, et présentée au cours de ce chapitre. Pour dresser cette taxinomie, nous avons relevé les grands principes sur lesquels les techniques sont fondées. En effet, la myriade de techniques existantes --- et nous prions le lecteur de nous pardonner d'en avoir omis beaucoup --- s'appuie \emph{in fine} sur un assez petit nombre de principes, mis en œuvre de manières plus ou moins diverses. Parfois, plusieurs principes sont combinés au sein d'une même technique, et c'est fréquemment le cas de la désambiguïsation, généralement appliquée à une technique fondée sur un curseur zonal, le lancer de rayon, ou la sélection en cascade. L'objectif de notre taxinomie est donc moins de ranger chaque technique dans une case bien définie que de mettre en lumière les principes fondateurs de l'ensemble des techniques de sélection, et leurs combinaisons possibles. Notre espoir est que ce travail d'analyse et de synthèse puisse informer ou inspirer le développement de nouvelles techniques, plus performantes, ou mieux adaptées à leurs contextes applicatifs.
    
    \subsection{Hétérogénéité des protocoles et des métriques}
    Les différentes techniques évaluées ici sont fondées sur des principes différents ; souvent, elles découlent aussi d'approches différentes, elles-mêmes issues de problématiques variées. \emph{AttachedShock}~\cite{you2012attachedshock, you2014attachedshock}, par exemple, cherche à répondre à un besoin très spécifique en réalité augmentée : la sélection d'objets fixes, mais en apparence \og fuyants \fg{} du fait de la vitesse de l'utilisateur véhiculé. C'est bien différent de la problématique qui sous-tend le développement du \emph{Bubble Cursor}~\cite{grossman2005bubble}, ou des diverses techniques de lancer de rayon.
    
    À problématiques différentes, approches différentes, et à approches différentes, protocoles d'évaluations et métriques différents. De fait, une comparaison directe de toutes les techniques passées en revue ici, dans les mêmes conditions et avec les mêmes métriques, est impossible. Ce n'est pas nécessairement un problème, car il est de toute manière plus pertinent d'évaluer chaque technique dans son contexte propre, ce que tâchent de faire leurs auteurs. C'est notamment la raison pour laquelle nous présentons les résultats sous forme graphique plutôt que numérique --- outre le fait que les valeurs numériques ne sont pas toujours communiquées. En effet, les graphiques permettent de tirer des enseignements qualitatifs qui, dans une perspective globale, sont sans doute plus précieux que des observations quantitatives (potentiellement) très dépendantes de chaque protocole et de ses paramètres spécifiques.
    
    \subsection{Techniques pour cibles statiques}
	\subsubsection{Curseurs zonaux}
    Les curseurs zonaux augmentent la taille effective des cibles en y ajoutant celle du curseur. Le \emph{Bubble Cursor}~\cite{grossman2005bubble} pousse ce concept à sa conclusion logique en transformant chaque point de l'espace en un proxy permettant de sélectionner la cible la plus proche ; ce principe fonctionne en 2D comme en 3D. \emph{DynaSpot}~\cite{chapuis2009dynaspot} adopte une approche similaire mais dépendant de la vitesse du curseur, et non de connaissances \emph{a priori} sur les positions des cibles. Ces systèmes dépendent de la densité de l'environnement : plus celle-ci est faible, plus ils sont efficaces, et inversement. En outre, ils ne tiennent pas compte du mouvement des cibles et ne sont pas particulièrement aptes à faciliter la sélection de cibles mobiles. De fait, nous ne saurions les recommander pour de telles cibles en environnement dense. Cependant, ils peuvent être combinés à d'autres techniques, et méritent donc notre attention.
    
	\subsubsection{\emph{Raycasting}, ou lancer de rayon}
    Une approche radicalement différente consiste à lancer un rayon ou un cône dans l'espace virtuel pour pouvoir sélectionner un objet en le \og touchant \fg{} avec ce rayon~\cite{liang1994jdcad}. Cependant, le lancer de rayon --- et surtout de cône --- souffre d'un problème majeur : l'ambiguïté lorsque plusieurs objets sont traversés par le rayon ou le cône. Pour pallier ce défaut, des solutions de désambiguïsation sont régulièrement mises en place~\cite{grossman2006design}. Elles sont diverses et leurs efficacités respectives varient, notamment selon les circonstances. Sans désambiguïsation, le lancer de rayon/cône se montre rapidement inutilisable en environnement dense ; avec, il peut fournir de bons résultats. Cependant, cela n'a été montré que sur des cibles statiques, et l'on peut douter de l'efficacité de cette approche avec des cibles mobiles, compte tenu de la précision déjà requise avec des objets statiques. Néanmoins, une heuristique de prédiction de l'intention de l'utilisateur peut apporter des gains significatifs. Mais pur ou même accompagné d'une solution de désambiguïsation efficace, le \emph{raycasting} est assez mal adapté aux environnements denses et surtout dynamiques.
    
	\subsubsection{Sélection en cascade}
    Pour gérer la difficulté d'une tâche de sélection, celle-ci peut être divisée en sous-tâches, dans une approche dite de sélection en cascade, consistant souvent à pré-sélectionner une zone de l'espace virtuel afin d'éliminer les objets s'y trouvant, avant de procéder à une seconde phase de sélection, plus fine, pouvant éventuellement être de nouveau subdivisée. La sélection en cascade peut fournir de bons temps de sélection, et permet souvent une réduction drastique du taux d'erreurs~\cite{kopper2011rapid}. Parfois, la première phase grossière tire parti d'une estimation de la direction du regard de l'utilisateur~\cite{debarba2013disambiguation}.
    
    De manière générale, la sélection en cascade a un inconvénient inhérent à son principe même : le nombre de tâches de sélection augmente, et est au minimum doublé. L'hypothèse motivant la mise en \oe{}uvre d'une telle technique est que les sous-tâches prendront un temps total inférieur à celui de la tâche originelle ; mais ce n'est malheureusement pas toujours le cas. Dans le cas plus spécifique des cibles mobiles, un autre problème s'ajoute. En effet, à partir du moment où une pré-sélection a été faite, les objets qui n'ont pas été pré-sélectionnés sont écartés d'une manière ou d'une autre. En soi, cela peut être gênant car la présence de ces objets et leurs interactions dans le temps avec les objets pré-sélectionnés peuvent avoir de l'importance pour l'utilisateur. Il s'agit là encore de préserver le contexte dynamique de la situation, dont les objets pré-sélectionnés se retrouvent souvent extraits. Parfois, la déconnexion de leur contexte spatio-temporel est totale.
    
	Une autre forme de sélection en cascade est possible : le filtrage sémantique. Dans le cas d'une simulation moléculaire, par exemple, l'utilisateur, sachant qu'il veut sélectionner un atome d'azote, pourrait communiquer cette intention au système qui, en retour, désactiverait la sélection de tout autre objet, en l'indiquant par un retour graphique. Cela aurait pour effet de réduire la densité effective de l'environnement d'un point de vue moteur, et éventuellement visuel, mais sans perdre (totalement) le contexte dynamique. L'efficacité pratique d'un tel filtrage repose néanmoins sur la capacité de l'effectuer rapidement et de manière fiable. L'usage de commandes vocales est particulièrement tentant pour une telle sous-tâche, mais présente les inconvénients inhérents au traitement du signal habituels : erreurs et imprécisions de reconnaissance, latence, coût, complexité, etc.
    
    En somme, le principe de sélection en cascade est fort intéressant, à condition de pouvoir minimiser le coût temporel de la multiplication des sous-tâches, et de ne pas perdre le contexte dynamique.

	\subsubsection{Prédiction de la trajectoire du curseur}
    Plutôt que de chercher à optimiser les paramètres de la tâche de sélection (taille ou distance effectives) il est possible d'analyser la trajectoire du curseur pendant la tâche, et d'essayer de prédire son point d'arrivée à l'avance, afin d'accélérer la sélection. KEP~\cite{lank2007endpoint} et SPEED~\cite{wonner2011speed} fonctionnent sur ce principe. En examinant le profil de vitesse en fonction du temps d'un curseur, connaissant les lois qui gouvernent la forme de ces profils, et sur l'hypothèse d'une trajectoire à peu près rectiligne, l'on peut estimer le point d'arrivée d'un curseur. En pratique, les performances obtenues peuvent être bonnes, mais cette approche s'accommode mal des environnements denses. Surtout, il est fort douteux qu'elle puisse s'appliquer efficacement aux cibles mobiles : si la trajectoire d'un curseur est supposée rectiligne, l'est-elle réellement quand la cible est mobile, voire rapide ? Si oui, vise-t-elle la position de la cible à l'instant où le mouvement débute, ou la position où l'utilisateur estime qu'elle sera à la fin du mouvement ? Ces questions restent à notre connaissance ouvertes à ce jour, et l'usage d'une telle approche ne nous paraît pas envisageable avant d'y avoir répondu et avant d'avoir analysé les implications des réponses. Notons au passage qu'il s'agit d'une forme de prédiction intentionnelle, mais nous la traitons à part car elle ne repose que sur un mouvement isolé, et non sur une succession d'actions dans le temps.

    \subsection{Techniques pour cibles mobiles}
	\subsubsection{Augmentation des objets}
    D'autres techniques, spécifiquement développées pour la sélection de cibles mobiles, augmentent les objets d'un appendice (\emph{Comet}~\cite{hasan2011comet}), ou d'une onde de choc (\emph{AttachedShock}~\cite{you2012attachedshock, you2014attachedshock}). Il s'agit là encore d'augmenter la taille effective des cibles, mais en tenant compte de leur mobilité. Bien que souvent efficaces, et ce d'autant plus qu'elles peuvent être combinées à un curseur zonal, ces techniques souffrent du même inconvénient que ces derniers : la densité réduit considérablement leur intérêt, d'une part à cause du chevauchement potentiel des cibles augmentées, et d'autre part à cause de l'encombrement visuel impliqué par l'augmentation. Celle-ci peut en effet occulter des éléments importants, ou poser de graves problèmes esthétiques, particulièrement dans des contextes d'une nature (au moins partiellement) artistique, tels que les jeux vidéo. Quand les environnements sont denses, quand une charte graphique doit être respectée, ou quand l'encombrement visuel doit être minimisé, ces techniques devraient selon nous être écartées.
    
	\subsubsection{Manipulation du temps}
    Les techniques spécifiquement pensées pour les cibles mobiles adoptent parfois une solution radicale : les rendre statiques. C'est le cas de \emph{Hold}~\cite{hajri2011moving}, qui se contente de stopper tous les objets pendant la phase de sélection, mais aussi de \emph{Target Ghost}~\cite{hasan2011comet}, qui crée des copies statiques des cibles qui, elles, demeurent mobiles, mais semi-transparentes. Cette dernière technique a l'avantage de ne pas perdre le contexte dynamique. Mais elle a aussi l'inconvénient de doubler le nombre d'objets affichés, et ceux qui sont voués à être sélectionnés (les copies statiques) demeurent détachés de leur contexte dynamique. De plus, si les objets ne sont pas visuellement différents les uns des autres, il peut être impossible pour l'utilisateur de relier une copie statique à l'objet qui l'a engendrée. Là encore, les applications à forte densité ne peuvent se satisfaire d'une technique de ce type, et ce d'autant plus que le contexte dynamique est important, ou que les objets sont visuellement similaires.
    
	\subsubsection{Prédiction intentionnelle}
    Une autre approche prédictive consiste à observer le comportement de l'utilisateur deviner son intention et déterminer quel objet il souhaite sélectionner. C'est ainsi que fonctionnent \emph{IntenSelect}~\cite{de2005intenselect} (une forme de lancer de rayon) et \emph{Hook}~\cite{ortega2013hook} (qui fait usage d'un curseur ponctuel). Un avantage est de ne pas dépendre d'hypothèses \og fragiles \fg{} avec des cibles mobiles, telles que la rectitude de la trajectoire du curseur. L'hypothèse généralement commune aux techniques de ce type est que l'utilisateur va chercher à \og suivre \fg{} sa cible pour la capturer, donc que ses mouvements seront corrélés à ceux de la cible. Cette corrélation est exploitée pour déterminer quel objet est visé par l'utilisateur. En pratique les résultats sont généralement très bons, et si certaines interrogations demeurent, notamment concernant la robustesses des techniques de ce genre face à des objets sujets à des mouvements de natures variées, ou dans des environnements extrêmement denses, la prédiction d'intention ressort de notre étude comme la voie la plus prometteuse pour la sélection de cibles mobiles en environnement dense. Par ailleurs, elle n'est pas incompatible avec d'autres approches mentionnées plus haut, telles que la sélection en cascade, par exemple.
    
\section{Conclusion}
    Les techniques d'assistance à la sélection de cibles visent généralement à optimiser les paramètres de la tâche définis par Fitts~\cite{fitts1954information} : la taille effective de la cible, et sa distance effective au curseur. Cette tendance illustre l'influence considérable de la loi de Fitts sur le développement de telles techniques. De fait, ces approches sont généralement efficaces pour la sélection de cibles statiques. Lorsque la densité augmente, les bénéfices apportés par les techniques de ce type tendent à chuter de manière drastique. Le \emph{Bubble Cursor}~\cite{grossman2005bubble} en est peut-être l'exemple le plus emblématique, en dépit de ses indiscutables qualités. Or, dans une tâche de sélection de cibles mobiles, le mouvement peut être bien plus déterminant que la taille ou la distance au curseur pour les performances, comme nous le verrons plus en détail dans les chapitres suivants.
    
    La largeur de la cible telle que prise en compte par le modèle de Fitts demeure pertinente. Cependant, dans les environnements denses, son augmentation directe pose problème du fait de l'encombrement visuel, et du chevauchement des cibles qui en découle~\cite{mcguffin2002acquisition}. L'augmentation de la taille effective du curseur sans augmentation systématique de sa taille visible, comme avec le \emph{Bubble Cursor}, est sujette à des désagréments liés à la nature dynamique de l'environnement, rendant les structures sous-jacentes instables --- en l'occurrence, le diagramme de Voronoï généré. De fait, le \emph{Bubble Cursor} fournit des résultats nettement en retrait par rapport à \emph{Comet}, conçue spécialement pour les cibles mobiles~\cite{hasan2011comet}, surtout quand les mouvements de la cible sont imprévisibles --- et ils le sont moins dans l'évaluation menée par les auteurs que dans certaines applications identifiées au cours du chapitre~\ref{chap1}. De façon générale, les approches traditionnelles, si elles peuvent être utiles avec les cibles mobiles, ne sont pas orientées dans leur conception par le principal facteur de difficulté. Par conséquent, elles montrent rapidement leurs limites avec des cibles dont les mouvements sont rapides, ou imprévisibles. Les approches fondées sur la prédiction de l'intention de l'utilisateur, en revanche, s'appuient sur l'étude des mouvements de l'utilisateur dans le temps, alors qu'il cherche à saisir une cible mobile. De fait, elles sont souvent mieux adaptées à cette tâche, y compris en environnement dense. \emph{Hook} offre de bien meilleures performances que le \emph{Bubble Cursor}, par exemple~\cite{ortega2013hook}. Et même s'il ne fut pas comparé à \emph{Comet} par ses auteurs, les résultats relevés laissent supposer un net avantage pour \emph{Hook}, surtout sur les taux d'erreurs. Il est de plus possible de combiner les approches intentionnelles à d'autres techniques dans un processus de sélection en cascade, par exemple en s'appuyant sur une estimation de la direction du regard de l'utilisateur ou --- comme il nous paraît plus judicieux compte tenu des contraintes inhérentes à certaines des applications détaillées dans le premier chapitre de ce manuscrit --- sur un filtrage sémantique, par exemple via des commandes vocales. Un couplage avec une assistance haptique ou pseudo-haptique~\cite{lecuyer2009simulating, pusch2011pseudo}, visant par exemple à guider l'utilisateur vers la cible prédite afin d'accélérer la sélection et/ou de réduire le taux d'erreurs, semble également prometteur.
    
    Notons surtout que la loi de Fitts est d'une valeur inestimable pour la conception de techniques d'assistance à la sélection de cibles lorsque cette loi modélise correctement la tâche. Il apparaît donc qu'un modèle de la sélection de cibles mobiles présenterait un intérêt comparable, et que les travaux dans ce domaine font cruellement défaut. Il devrait permettre non seulement de décrire la nature d'un mouvement, mais encore de le générer, et d'estimer la difficulté de sélection d'une cible ainsi animée.